---
title: "Model extension"
author: "Jong-Hoon Kim"
date: "2025-12-22                                                    "
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
library(MASS)
library(Matrix)
library(dplyr)
library(ggplot2)
```

# Spatially correlated outbreak risks and spillover

This section presents a description of the outbreak and vaccination model. The exposition is organized to move from baseline risk, to spillover, to vaccination, and finally to expected costs. The framework is static (one-year) and designed to balance realism with analytical transparency.

---

## Notation and setup

We consider a population divided into $n$ spatial units (grid cells), indexed by $i \in \{1,\dots,n\}$.

- Neighborhood of cell $i$: $\mathcal{N}(i)$ (e.g., rook or queen adjacency)
- Adjacency indicator: $A_{ij} = \mathbf{1}\{j \in \mathcal{N}(i)\}$
- Primary outbreak indicator: $Y_i^{(0)} \in \{0,1\}$
- Secondary (spillover) outbreak indicator: $Y_i^{(1)} \in \{0,1\}$
- Final outbreak indicator: $Y_i \in \{0,1\}$
- Baseline outbreak probability: $p_i \in (0,1)$
- Spillover strength parameter: $\eta \in [0,1]$

We distinguish between **primary outbreaks**, driven by baseline vulnerability, and **secondary outbreaks**, arising through local spillover from neighboring primary outbreaks.

---

## Spatially correlated baseline outbreak risk

Each cell $i$ has a baseline probability $p_i$ of experiencing a primary outbreak, representing environmental, infrastructural, and socio-demographic vulnerability prior to local transmission.

Baseline risks are generated from a latent spatial field,
$$
Z \sim \mathcal{N}(0, \Sigma(\phi)), \qquad
p_i = \mathrm{logit}^{-1}(\mu + Z_i),
$$
where $\Sigma(\phi)$ encodes spatial dependence and $\phi$ controls the strength and range of correlation. The intercept $\mu$ sets the overall mean outbreak probability.

Conditional on $p=(p_1,\dots,p_n)$, primary outbreaks occur independently:
$$
Y_i^{(0)} \mid p_i \sim \mathrm{Bernoulli}(p_i), \qquad i=1,\dots,n.
$$

---

## Spillover-driven secondary outbreaks

Let
$$
K_i = \sum_{j \in \mathcal{N}(i)} Y_j^{(0)}
$$
denote the number of neighboring primary outbreaks.

Spillover is modeled using a monotone dose–response function,
$$
h(K_i) = 1 - (1-\eta)^{K_i},
$$
which satisfies $h(0)=0$ and increases smoothly with $K_i$.

Conditional on $K_i$,
$$
Y_i^{(1)} \mid K_i \sim \mathrm{Bernoulli}\!\left(h(K_i)\right).
$$

The final outbreak indicator is
$$
Y_i = 1 - (1 - Y_i^{(0)})(1 - Y_i^{(1)}),
$$
so that
$$
\Pr(Y_i = 1 \mid p, K_i)
= p_i + (1-p_i)\,h(K_i).
$$

This reduced-form representation captures spatial amplification of outbreak risk without explicitly modeling transmission dynamics.

Secondary outbreaks do not generate further spillover; this prevents epidemic cascades and keeps the model analytically tractable.
---

## Vaccination effects

Let $V_i \in \{0,1\}$ indicate whether cell $i$ is vaccinated pre-emptively.

Vaccination modifies both baseline risk and spillover susceptibility:

- **Baseline risk reduction**
$$
p_i(V_i) = (1-\nu V_i)\,p_i,
$$
where $\nu \in [0,1]$ is effectiveness against primary outbreaks.

- **Spillover susceptibility reduction**
$$
\eta(V_i) = (1-\kappa V_i)\,\eta,
$$
where $\kappa \in [0,1]$ captures protection against secondary spread.

These modified quantities are substituted directly into the outbreak equations.

---

## Expected outbreak probability (cell level)

Conditioning on baseline risks $p$, the expected outbreak probability in cell $i$ is
$$
\mathbb{E}[Y_i \mid p]
=
p_i + (1-p_i)\left(1-\prod_{j\in\mathcal{N}(i)}(1-\eta p_j)\right).
$$

Spillover therefore depends on the joint configuration of neighboring baseline risks, not merely their average.

Vaccination does not reduce infectiousness of neighbors (i.e., no outward spillover reduction), only susceptibility.
---

## Expected outbreak count

Let
$$
N_{\mathrm{out}} = \sum_{i=1}^n Y_i
$$
denote the total number of outbreak cells.

Conditional on $p$,
$$
\mathbb{E}[N_{\mathrm{out}} \mid p]
=
\sum_{i=1}^n
\left[
p_i + (1-p_i)\left(1-\prod_{j\in\mathcal{N}(i)}(1-\eta p_j)\right)
\right].
$$

When $p$ itself is random and spatially correlated,
$$
\mathbb{E}[N_{\mathrm{out}}]
=
\mathbb{E}_p\!\left[\mathbb{E}[N_{\mathrm{out}} \mid p]\right].
$$
This quantity does not admit a closed form and is evaluated via Monte Carlo simulation.

---

## Expected total cost under a mixed vaccination strategy

### Decisions and constraints

- Pre-emptive vaccination: $V_i \in \{0,1\}$ (chosen before outbreaks)
- Reactive vaccination: $R_i \in \{0,1\}$ (chosen after observing outbreaks), with $R_i \le Y_i$
- Vaccine cost per cell: $C_V$
- Unmitigated outbreak cost per cell: $C_I$
- Cost ratio: $R = C_I/C_V$
- Reactive effectiveness: $r \in [0,1]$

Total vaccination capacity allows vaccination of a fraction $f$ of cells. A fraction $\alpha$ is allocated pre-emptively, leaving reactive capacity
$$
B_{\mathrm{re}} = (1-\alpha) f n.
$$

Reactive vaccination is subject to the followig rule,
$$
\sum_{i=1}^n R_i = \min(N_{\mathrm{out}}, B_{\mathrm{re}}).
$$

---

### Expected cost

Vaccination cost:
$$
C_{vacc}
=
C_V\sum_{i=1}^n V_i
+
C_V\,\mathbb{E}\!\left[\sum_{i=1}^n R_i\right].
$$

Outbreak cost:
$$
\mathbb{E}[C_{out}]
=
C_I\left(
\mathbb{E}[N_{out}]
-
r\,\mathbb{E}\!\left[\sum_{i=1}^n R_i\right]
\right).
$$

Total expected cost:
$$
\mathbb{E}[C_{\mathrm{total}}]
=
C_V\sum_{i=1}^n V_i
+
C_I\,\mathbb{E}[N_{\mathrm{out}}]
+
(C_V-rC_I)\,
\mathbb{E}\!\left[\min(N_{\mathrm{out}}, B_{\mathrm{re}})\right].
$$

---

## Role of spillover

Spillover influences expected costs only through the distribution of $N_{\mathrm{out}}$. There is no direct spillover term in the cost function; all effects are mediated by changes in outbreak occurrence.

---

## Simulation workflow

Expected costs are evaluated by Monte Carlo simulation:

1. Draw a spatially correlated risk field $p$
2. Sample primary outbreaks $Y^{(0)}$
3. Compute $K_i$ and sample secondary outbreaks $Y^{(1)}$
4. Construct final outbreaks $Y$ and $N_{\mathrm{out}}$
5. Apply reactive allocation
6. Compute realized costs and average across replicates

---

## Patch summaries and allocation



```{r}
allocate_preemptive_targeted <- function(patch_df, B_pre) {
  ord <- order(patch_df$S_hat, decreasing = TRUE)
  used <- 0
  pre_vax <- rep(FALSE, nrow(patch_df))

  for (k in ord) {
    if (used + patch_df$m[k] <= B_pre) {
      pre_vax[k] <- TRUE
      used <- used + patch_df$m[k]
    }
  }

  list(pre_vax = pre_vax, used = used)
}
```

---

### Mixed outbreak mechanism

```{r}
# compute the number of cells with outbreaks
draw_outbreak_adj <- function(p, adj, V = NULL, 
                              eta = 0.6, nu = 0.8, kappa = 0.8) {

  n <- length(p)
  if (is.null(V)) V <- rep(FALSE, n)

  p_eff <- p * (1 - nu * V)
  eta_eff <- eta * (1 - kappa * V)

  Y0 <- rbinom(n, 1, p_eff) == 1L
  K <- vapply(seq_len(n), function(i) sum(Y0[adj[[i]]]), integer(1))
  h <- 1 - (1 - eta_eff)^K
  Y1 <- rbinom(n, 1, h) == 1L

  Y <- Y0 | (!Y0 & Y1)
  list(Y = Y, Y0 = Y0, Y1 = Y1)
}
```

---

### Mixed strategy simulation

```{r}
simulate_patch_spillover <- function(p_true, score_cell,
                                     adj, patches, patch_df,
                                     alpha, f, R, r,
                                     eta = 0.2, nu = 0, kappa = 0,
                                     seed = NULL) {

  if (!is.null(seed)) set.seed(seed)
  
  stopifnot(alpha >= 0, alpha <= 1, f > 0, f <= 1, R >= 0, r >= 0, r <= 1,
            is.numeric(p_true), all(p_true > 0), all(p_true < 1),
            is.numeric(score_cell), length(score_cell) == length(p_true))
  
  patches <- patches[!vapply(patches, is.null, logical(1))]
  Kpatch  <- length(patches)
  stopifnot(nrow(patch_df) == Kpatch)
  
  n <- length(p_true)
  
  # Budgets in number of CELLS
  B_pre   <- alpha * f * n
  B_react <- (1 - alpha) * f * n
  # -------------------------------------------------
  # 1. Pre-emptive vaccination (PATCH level, score-based)
  # -------------------------------------------------
  
  pre <- allocate_preemptive_targeted(patch_df, B_pre = B_pre)
  pre_vax_patch <- as.logical(pre$pre_vax)
  used_pre <- as.numeric(pre$used)
  
  V_pre_cell <- rep(FALSE, n)
  if (any(pre_vax_patch)) {
    for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
  }
  
  # -------------------------------------------------
  # 2. Outbreak realization (CELL level, true risk)
  # -------------------------------------------------
  outb <- draw_outbreak_adj(
    p = p_true,
    adj = adj,
    V = V_pre_cell,
    eta = eta,
    nu = nu,
    kappa = kappa
  )
  
  Y_cell  <- as.logical(outb$Y)
  Y0_cell <- outb$Y0
  Y1_cell <- outb$Y1
  
  # -------------------------------------------------
  # 3. Reactive vaccination (CELL level, observation-only)
  # -------------------------------------------------
  
  outbreak_cells <- which(Y_cell & !V_pre_cell)
  
  used_react <- min(length(outbreak_cells), floor(B_react))
  react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)
  
  V_react_cell <- rep(FALSE, n)
  if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE
  
  V_any_cell <- V_pre_cell | V_react_cell
  
  # -------------------------------------------------
  # 4. Costs (CELL level)
  # -------------------------------------------------
  
  vax_cost_total <- used_pre + used_react
  
  outbreak_cost <- R * sum(
    as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1)
  )
  
  total_cost <- vax_cost_total + outbreak_cost
  
  # -------------------------------------------------
  # 5. Derived PATCH summaries (reporting only
  # -------------------------------------------------
  
  outbreak_patch <- vapply(
    seq_len(Kpatch),
    function(k) any(Y_cell[patches[[k]]]),
    logical(1)
  )
  
  react_vax_patch <- vapply(
    seq_len(Kpatch),
    function(k) any(V_react_cell[patches[[k]]]),
    logical(1)
  )
  
  list(
    total_cost = total_cost,
    vax_cost = vax_cost_total,
    outbreak_cost = outbreak_cost,
    # Cell-level (primary outputs)
    V_pre_cell = V_pre_cell,
    V_react_cell = V_react_cell,
    V_any_cell = V_any_cell,
    Y_cell = Y_cell,
    Y0_cell = Y0_cell,
    Y1_cell = Y1_cell,
    
    # Patch-level (derived)
    pre_vax_patch = pre_vax_patch,
    react_vax_patch = react_vax_patch,
    outbreak_patch = outbreak_patch,
    
    # Bookkeeping
    used_pre = used_pre,
    used_react = used_react,
    B_pre = B_pre,
    B_react = B_react
  )
}

```

---

### Monte Carlo evaluation and optimization

```{r}
estimate_cost_alpha_patch_spillover <- 
  function(p_true, score_cell, adj, patches, patch_df,
           alpha, f, R, r, eta = 0.2, nu = 0, kappa = 0,
           n_mc = 2000, seed = NULL) {

  if (!is.null(seed)) set.seed(seed)
  
  costs <- replicate(n_mc, {
  simulate_patch_spillover(
    p_true = p_true, score_cell = score_cell,
    adj = adj, patches = patches, patch_df = patch_df,
    alpha = alpha, f = f, R = R, r = r,
    eta = eta, nu = nu, kappa = kappa)$total_cost
  })
  
  c(mean = mean(costs), sd = sd(costs))
}

```

```{r}
alpha_star_patch_grid_spillover <- 
  function(p_true, score_cell, adj, patches, patch_df,
           f, R, r, eta = 0.2, nu = 0, kappa = 0,
           alpha_grid = seq(0, 1, by = 0.05), n_mc = 2000, seed = NULL) {

  res <- data.frame(alpha = alpha_grid, mean_cost = NA_real_)
  
  for (i in seq_along(alpha_grid)) {
    res$mean_cost[i] <- estimate_cost_alpha_patch_spillover(
      p_true = p_true, score_cell = score_cell,
      adj = adj, patches = patches, patch_df = patch_df,
      alpha = alpha_grid[i], f = f, R = R, r = r,
      eta = eta, nu = nu, kappa = kappa,
      n_mc = n_mc, seed = seed)["mean"]
  }

  list(alpha_star = res$alpha[which.min(res$mean_cost)], grid = res)
}
```

---

# Example run

```{r}
nx <- 25; ny <- 20
rho0_val <- 0.6
ell_val <- 4
theta_val <- 3

rho_target_val <- 0.7
n_seeds_val <- 10
patch_size_val = 40
  
alpha_val <- 0.5
f_val <- 0.3
R_val <- 5
r_val <- 0.6
eta_val <- 0.8
nu_val <- 0.9
kappa_val <- 0.8

n_mc = 1000
  
coords <- as.matrix(expand.grid(x = 1:nx, y = 1:ny))

sim <- spatial_beta_risk(coords, theta = theta_val, 
                         rho0 = rho0_val, ell = ell_val)
p_true <- sim$p

rank_out <- make_ranking(p_true, rho_target = rho_target_val)
score_cell <- rank_out$score

adj <- make_adj(coords, type = "distance", d0 = 1.01)

patch_out <- make_patches(score_cell, 
                                 adj,
                                 n_seeds = n_seeds_val, 
                                 patch_size = patch_size_val)
patches <- patch_out$patches
patches <- patches[!vapply(patches, is.null, logical(1))]

patch_df <- summarize_patches(p_true, score_cell, patches)

opt <- alpha_star_patch_grid_spillover(
  p_true = p_true, 
  score_cell = score_cell, 
  adj = adj, 
  patches = patches, 
  patch_df = patch_df,
  f = f_val, R = R_val, r = r_val,
  eta = eta_val, nu = nu_val, kappa = kappa_val, 
  alpha_grid = seq(0, 1, by = 0.02),
  n_mc = 2000,
  seed = 1
)
opt$alpha_star

ggplot(opt$grid, aes(alpha, mean_cost)) +
  geom_line() +
  theme_light()
```


# Figures

## Figure 1. Spatially correlated risks $p_i$

```{r, fig.width=7, fig.height=4.5}
df_risk <- data.frame(
  x = coords[,1],
  y = coords[,2],
  p = p_true
)

ggplot(df_risk, aes(x = x, y = y, fill = p)) +
  geom_tile() +
  coord_equal() +
  labs(title = expression("Spatially correlated risks " * italic(p)[i]),
       x = NULL, y = NULL, fill = "p_i") +
  theme_minimal(base_size = 12)
```

## Figure 2. Imperfect risk score vs true risk

```{r, fig.width=6.5, fig.height=4.2}
df_score <- data.frame(p = p_true, score = score_cell)
ggplot(df_score, aes(x = p, y = score)) +
  geom_point(alpha = 0.4) +
  labs(title = paste0("Imperfect score vs true risk (Spearman rho = ",
                      round(rank_out$rho_achieved, 2), ")"),
       x = expression(italic(p)[i]), y = "score_i") +
  theme_minimal(base_size = 12)
```

## Figure 3. Patch map

```{r, fig.width=7, fig.height=4.5}
patch_id_vec <- patch_out$patch_id
df_patchmap <- data.frame(
  x = coords[,1],
  y = coords[,2],
  patch = factor(patch_id_vec)
)

ggplot(df_patchmap, aes(x = x, y = y, fill = patch)) +
  geom_tile() +
  coord_equal() +
  guides(fill = "none") +
  labs(title = "Patches (contiguous groups grown from high-score seeds)",
       x = NULL, y = NULL) +
  theme_minimal(base_size = 12)
```

## Figure 4.Simulated pre-emptive vs reactive vs outbreaks

```{r, fig.width=8, fig.height=4.8, include=F}
sim <- simulate_patch_spillover(
  p_true = p_true,
  score = score_cell,
  adj = adj,
  patches = patches,
  patch_df = patch_df,
  alpha = alpha_val, f = f_val, R = R_val, r = r_val,
  eta = eta_val, nu = nu_val, kappa = kappa_val
)

df_state <- 
  data.frame(
    x = coords[,1],
    y = coords[,2],
    pre = sim$V_pre_cell,
    react = sim$V_react_cell,
    out = sim$Y_cell
  ) %>%
  mutate(state = dplyr::case_when(
    out & react ~ "Outbreak + reactive",
    out & !react ~ "Outbreak (unmitigated)",
    !out & pre ~ "Pre-emptive vaccinated",
    !out & react ~ "Reactive vaccinated (no outbreak)",
    TRUE ~ "None")
  )

ggplot(df_state, aes(x = x, y = y, fill = state)) +
  geom_tile() +
  coord_equal() +
  labs(title = paste0("Realization (alpha = ", alpha_val, ")"),
       x = NULL, y = NULL, fill = NULL) +
  theme_minimal(base_size = 12)
```

## Figure 5. Cost curve across $\alpha$ and estimated $\alpha^*$

```{r, fig.width=7, fig.height=4.5}
opt <- alpha_star_patch_grid_spillover(
  p_true = p_true,
  score_cell = score_cell,
  adj = adj,
  patches = patches,
  patch_df = patch_df,
  f = f_val, R = R_val, r = r_val,
  eta = eta_val, nu = nu_val, kappa = kappa_val,
  alpha_grid = seq(0, 1, by = 0.02),
  n_mc = 2000,
  seed = 1
)

ggplot(opt$grid, aes(x = alpha, y = mean_cost)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  geom_vline(xintercept = opt$alpha_star, linetype = "dashed") +
  labs(title = paste0("Mean cost vs alpha (alpha* = ", opt$alpha_star, ")"),
       x = expression(alpha),
       y = "Mean cost (units of C_V)") +
  theme_minimal(base_size = 12)
```

---
### Experiement

Compare two alternative vaccination strategies. In Strategy A, pre-emptive vaccination occurs at the patch level after accounting for spill-over risk in addition to cell-level risk (environmental factors). In Strategy B, pre-emptive vaccination occurs at the cell level that only accounts for the cell-level risk (environmental factors). Reactive vaccination occurs at the cell level in both strategies.

```{r}
augment_risk_spillover <- function(p_true, adj, eta) {
  n <- length(p_true)
  p_aug <- numeric(n)

  for (i in seq_len(n)) {
    nb <- adj[[i]]
    if (length(nb) == 0L) {
      p_aug[i] <- p_true[i]
    } else {
      p_aug[i] <- p_true[i] + (1 - p_true[i]) * (1 - prod(1 - eta * p_true[nb]))
    }
  }
  pmin(pmax(p_aug, 0), 1)
}

```

2) Strategy A: Cell-level pre-emptive simulator (thin wrapper)

```{r}
simulate_cell_spillover <- function(p_true, score_cell,
                                    adj,
                                    alpha, f, R, r,
                                    eta = 0.2, nu = 0, kappa = 0,
                                    seed = NULL) {

  if (!is.null(seed)) set.seed(seed)

  stopifnot(length(p_true) == length(score_cell))
  n <- length(p_true)

  # Budgets in CELLS
  B_pre   <- alpha * f * n
  B_react <- (1 - alpha) * f * n

  # -------------------------------------------------
  # 1) Pre-emptive vaccination (CELL level, score-based)
  # -------------------------------------------------
  ord <- order(score_cell, decreasing = TRUE)
  used_pre <- min(floor(B_pre), n)
  pre_cells <- if (used_pre > 0) ord[seq_len(used_pre)] else integer(0)

  V_pre_cell <- rep(FALSE, n)
  if (length(pre_cells) > 0) V_pre_cell[pre_cells] <- TRUE

  # -------------------------------------------------
  # 2) Outbreak realization (CELL level, true risk)
  # -------------------------------------------------
  outb <- draw_outbreak_adj(
    p = p_true,
    adj = adj,
    V = V_pre_cell,
    eta = eta,
    nu = nu,
    kappa = kappa
  )
  Y_cell <- as.logical(outb$Y)

  # -------------------------------------------------
  # 3) Reactive vaccination (CELL level, observation-only)
  # -------------------------------------------------
  outbreak_cells <- which(Y_cell & !V_pre_cell)

  used_react <- min(length(outbreak_cells), floor(B_react))
  react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

  V_react_cell <- rep(FALSE, n)
  if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

  # -------------------------------------------------
  # 4) Costs (CELL level, units of C_V)
  # -------------------------------------------------
  vax_cost_total <- used_pre + used_react

  outbreak_cost <- R * sum(
    as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1)
  )

  total_cost <- vax_cost_total + outbreak_cost

  list(
    total_cost = total_cost,
    vax_cost = vax_cost_total,
    outbreak_cost = outbreak_cost,
    V_pre_cell = V_pre_cell,
    V_react_cell = V_react_cell,
    Y_cell = Y_cell,
    used_pre = used_pre,
    used_react = used_react,
    B_pre = B_pre,
    B_react = B_react
  )
}

```

3) Strategy B: Patch-level pre-emptive, spillover-aware
We can recycle functions that we have 

- `make_patches(score, adj, ...)`
- `summarize_patches(p_true, score_cell, patches)` (uses mean score per patch)
- `allocate_preemptive_targeted(patch_df, B_pre)`
- `simulate_patch_spillover(...)` (does patch-level pre + cell-level reactive + cost)

We will feed it a spillover-aware score (derived from p_aug), while keeping outbreak generation driven by p_true.

4) Build the two strategy inputs (scores + patches)
This is the key “setup” function that you run once per scenario.
```{r}
build_strategy_objects <- function(p_true, adj,
                                   rho_cell = 0.7,
                                   rho_patch = 0.7,
                                   eta_score = 0.8,
                                   n_seeds = 10,
                                   patch_size = 40,
                                   seed_cell = 1,
                                   seed_patch = 2) {

  # ---- Strategy A score: cell-risk only (imperfect ranking of p_true)
  rank_cell <- make_ranking(p_true, rho_target = rho_cell, 
                                          seed = seed_cell)
  score_cell <- rank_cell$score

  # ---- Strategy B score: spillover-aware (imperfect ranking of augmented risk)
  p_aug <- augment_risk_spillover(p_true, adj, eta = eta_score)
  rank_patch <- make_ranking(p_aug, rho_target = rho_patch, seed = seed_patch)
  score_spill <- rank_patch$score

  # ---- Patches built from spillover-aware score (consistent with strategy B)
  patch_out <- make_patches(score_spill, adj,
                            n_seeds = n_seeds,
                            patch_size = patch_size)
  patches <- patch_out$patches
  patches <- patches[!vapply(patches, is.null, logical(1))]
  patch_df <- summarize_patches(p_true = p_true,
                                score_cell = score_spill,
                                patches = patches)

  list(
    # Strategy A
    score_cell = score_cell,
    rank_cell = rank_cell,

    # Strategy B
    p_aug = p_aug,
    score_spill = score_spill,
    rank_patch = rank_patch,
    patches = patches,
    patch_df = patch_df,
    patch_id = patch_out$patch_id
  )
}

```


```{r}
compare_cell_vs_patch <- function(p_true,
                                  score_cell,
                                  adj,
                                  patches, patch_df,
                                  score_spill,
                                  alpha, f, R, r,
                                  eta = 0.8, nu = 0.9, kappa = 0.8,
                                  n_mc = 1000, seed = 1) {

  set.seed(seed)
  seeds <- sample.int(1e9, n_mc)

  cost_cell  <- numeric(n_mc)
  cost_patch <- numeric(n_mc)

  for (b in seq_len(n_mc)) {
    s <- seeds[b]

    A <- simulate_cell_spillover(
      p_true = p_true,
      score_cell = score_cell,
      adj = adj,
      alpha = alpha, f = f, R = R, r = r,
      eta = eta, nu = nu, kappa = kappa,
      seed = s
    )

    B <- simulate_patch_spillover(
      p_true = p_true,
      score_cell = score_spill,  # used ONLY for patch targeting
      adj = adj,
      patches = patches,
      patch_df = patch_df,
      alpha = alpha, f = f, R = R, r = r,
      eta = eta, nu = nu, kappa = kappa,
      seed = s
    )

    cost_cell[b]  <- A$total_cost
    cost_patch[b] <- B$total_cost
  }

  df <- data.frame(
    cost_cell  = cost_cell,
    cost_patch = cost_patch,
    diff = cost_patch - cost_cell
  )

  list(
    summary = c(
      mean_cell  = mean(df$cost_cell),
      mean_patch = mean(df$cost_patch),
      mean_diff  = mean(df$diff),
      sd_diff    = sd(df$diff)
    ),
    draws = df
  )
}
```

Simulation parameters

```{r}
# --- build risks + adjacency (as you already do) ---
nx <- 25; ny <- 20
rho0_val <- 0.8
ell_val <- 20
theta_val <- 5
# rho_target_val <- 0.7
# n_seeds_val <- 10
# patch_size_val = 40
  
alpha_val <- 0.8
f_val <- 0.4
R_val <- 10
r_val <- 0.3
eta_val <- 0.9
nu_val <- 0.9
kappa_val <- 0.9

n_seeds_val <- 10
patch_size_val <- 2
```

Simulation
```{r}
coords <- as.matrix(expand.grid(x = 1:nx, y = 1:ny))

sim <- sim_spatial_beta_risk(coords, theta=theta_val, 
                             rho0=rho0_val, ell=ell_val)
p_true <- sim$p
adj <- make_adj(coords, type="rook")  # or distance/queen

# --- strategy objects ---
obj <- build_strategy_objects(
  p_true = p_true,
  adj = adj,
  rho_cell = 0.7,
  rho_patch = 0.7,
  eta_score = 0.8,
  n_seeds = n_seeds_val,
  patch_size = patch_size_val,
  seed_cell = 1,
  seed_patch = 2
)

# --- compare at a chosen alpha ---
res <- compare_cell_vs_patch(
  p_true = p_true,
  score_cell = obj$score_cell,
  adj = adj,
  patches = obj$patches,
  patch_df = obj$patch_df,
  score_spill = obj$score_spill,
  alpha = alpha_val, f = f_val, R = R_val, r = r_val,
  eta = eta_val, nu = nu_val, kappa = kappa_val,
  n_mc = 2000, seed = 1
)

res$summary

```

`allocate_preemptive_targeted()` is a greedy knapsack by patch size, but it can leave unused budget when patch sizes are chunky. That would confound a patch-size experiment (bigger patches look worse partly because you “wasted” doses).

Select best patches until you cannot add another patch without exceeding 
the budget for the pre-emptive vaccination. If leftover budget remains, top up with best remaining cells (by the same spillover-aware score) outside vaccinated cells.

This makes dose usage comparable across patch sizes.
```{r}
allocate_preemptive_patches_with_topup <- function(patch_df, patches, score_cell, B_pre, n) {
  ord <- order(patch_df$S_hat, decreasing = TRUE)

  V_pre <- rep(FALSE, n)
  used <- 0L

  # 1) take whole patches greedily
  for (k in ord) {
    m <- patch_df$m[k]
    if (used + m <= B_pre) {
      V_pre[patches[[k]]] <- TRUE
      used <- used + m
    }
  }

  # 2) top-up with best remaining cells (optional)
  leftover <- B_pre - used
  if (leftover > 0) {
    cand <- which(!V_pre)
    if (length(cand) > 0) {
      ord_cell <- cand[order(score_cell[cand], decreasing = TRUE)]
      take <- ord_cell[seq_len(min(leftover, length(ord_cell)))]
      V_pre[take] <- TRUE
      used <- used + length(take)
    }
  }

  list(V_pre_cell = V_pre, used = used)
}

```

```{r}
simulate_preemptive_by_patchsize <- function(p_true, adj,
                                            score_cell, 
                                            patch_size,
                                            n_seeds,
                                            alpha, f, R, r,
                                            eta = 0.2, nu = 0, kappa = 0,
                                            topup = TRUE,
                                            seed = NULL) {

  if (!is.null(seed)) set.seed(seed)
  n <- length(p_true)

  # budgets
  B_pre   <- floor(alpha * f * n)
  B_react <- floor((1 - alpha) * f * n)

  # ---- patch_size = 1 means "cell-level pre-emptive"
  if (patch_size == 1) {
    ord <- order(score_cell, decreasing = TRUE)
    pre_cells <- ord[seq_len(min(B_pre, n))]
    V_pre_cell <- rep(FALSE, n)
    V_pre_cell[pre_cells] <- TRUE
    used_pre <- sum(V_pre_cell)

    patches <- NULL
    patch_df <- NULL

  } else {

    # build patches using the SAME score_cell (spillover-aware score if you choose)
    patch_out <- make_patches(score_cell, adj,
                                     n_seeds = n_seeds,
                                     patch_size = patch_size)
    patches <- patch_out$patches
    patches <- patches[!vapply(patches, is.null, logical(1))]

    patch_df <- summarize_patches(p_true = p_true,
                                  score_cell = score_cell,
                                  patches = patches)

    if (topup) {
      alloc <- allocate_preemptive_patches_with_topup(
        patch_df = patch_df, patches = patches,
        score_cell = score_cell, B_pre = B_pre, n = n
      )
      V_pre_cell <- alloc$V_pre_cell
      used_pre <- alloc$used
    } else {
      pre <- allocate_preemptive_targeted(patch_df, B_pre = B_pre)
      used_pre <- as.integer(pre$used)
      pre_vax_patch <- as.logical(pre$pre_vax)
      V_pre_cell <- rep(FALSE, n)
      if (any(pre_vax_patch)) {
        for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
      }
      used_pre <- sum(V_pre_cell)
    }
  }

  # ---- outbreaks (true risk + spillover; identical)
  outb <- draw_outbreak_adj(
    p = p_true,
    adj = adj,
    V = V_pre_cell,
    eta = eta,
    nu = nu,
    kappa = kappa
  )
  Y_cell <- as.logical(outb$Y)

  # ---- reactive (cell-level, observation-only)
  outbreak_cells <- which(Y_cell & !V_pre_cell)
  used_react <- min(length(outbreak_cells), B_react)
  react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

  V_react_cell <- rep(FALSE, n)
  if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

  # ---- costs
  vax_cost_total <- used_pre + used_react
  outbreak_cost <- R * sum(as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1))
  total_cost <- vax_cost_total + outbreak_cost

  list(
    total_cost = total_cost,
    vax_cost = vax_cost_total,
    outbreak_cost = outbreak_cost,
    used_pre = used_pre,
    used_react = used_react,
    B_pre = B_pre,
    B_react = B_react,
    patch_size = patch_size,
    n_seeds = n_seeds
  )
}

```

```{r}
# spillover-aware risk proxy used ONLY for pre-emptive targeting
p_aug <- augment_risk_spillover(p_true, adj, eta = eta_val)

rank_out <- make_ranking(p_aug, rho_target = 0.8, seed = 1)
score_spill <- rank_out$score

```

```{r}
estimate_cost_by_patchsize <- function(p_true, adj, score_cell,
                                       patch_sizes = c(1, 2, 3, 5, 10, 20, 40),
                                       cover_mult = 2.0,     # controls n_seeds as patch_size changes
                                       alpha, f, R, r,
                                       eta = 0.2, nu = 0, kappa = 0,
                                       topup = TRUE,
                                       n_mc = 1000, seed = 1) {

  n <- length(p_true)

  # choose n_seeds so candidate patch pool stays roughly comparable
  # target pool ~ cover_mult * B_pre_max where B_pre_max = f*n (alpha=1)
  B_pre_max <- floor(f * n)
  L_target <- min(cover_mult * B_pre_max, n)

  set.seed(seed)
  seeds <- sample.int(1e9, n_mc)

  res <- lapply(patch_sizes, function(ps) {

    n_seeds <- if (ps == 1) NA_integer_ else ceiling(L_target / ps)

    costs <- numeric(n_mc)
    used_pre <- numeric(n_mc)

    for (b in seq_len(n_mc)) {
      sim <- simulate_preemptive_by_patchsize(
        p_true = p_true, adj = adj,
        score_cell = score_cell,
        patch_size = ps,
        n_seeds = if (is.na(n_seeds)) 1 else n_seeds,
        alpha = alpha, f = f, R = R, r = r,
        eta = eta, nu = nu, kappa = kappa,
        topup = topup,
        seed = seeds[b]
      )
      costs[b] <- sim$total_cost
      used_pre[b] <- sim$used_pre
    }

    data.frame(
      patch_size = ps,
      n_seeds = n_seeds,
      mean_cost = mean(costs),
      sd_cost = sd(costs),
      mean_used_pre = mean(used_pre)
    )
  })

  do.call(rbind, res)
}

```

Simulation across patch size
```{r}
eta_score <- eta_val  # often set equal to true eta

p_aug <- augment_risk_spillover(p_true, adj, eta = eta_score)
rank_out <- make_ranking(p_aug, rho_target = 0.7, seed = 1)
score_spill <- rank_out$score

df_ps <- estimate_cost_by_patchsize(
  p_true = p_true, adj = adj, score_cell = score_spill,
  patch_sizes = seq(1,60,2),
  cover_mult = 2.0,
  alpha = alpha_val, f = f_val, R = R_val, r = r_val,
  eta = eta_val, nu = nu_val, kappa = kappa_val,
  topup = TRUE,
  n_mc = 2000, seed = 1
)

ggplot(df_ps, aes(x = patch_size, y = mean_cost)) +
  geom_line() +
  geom_point(size = 1.5) +
  theme_minimal() +
  labs(x = "Patch size (cells)", y = "Mean total cost")

```

