---
title: "Model extension"
author: "Jong-Hoon Kim"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
library(MASS)
library(Matrix)
library(dplyr)
library(ggplot2)
source("R/load_all.R")
```


## Multiple Populations with Heterogeneous Outbreak Risk

We extend the equal-risk $n$-population model to allow heterogeneous
outbreak probabilities across populations and to incorporate targeting
accuracy for pre-emptive vaccination.

The pre-emptive and reactive fractions satisfy 
$$
f_{\mathrm{pre}} + f_{\mathrm{react}} = f.
$$

### Exponential hazard model

Assume each population has a latent outbreak hazard

$$
\Lambda_i \sim \mathrm{Exponential}(\theta), \qquad \theta > 0.
$$

The outbreak probability for population $i$ is 

$$
p_i = 1 - e^{-\Lambda_i}, \qquad p_i \in (0,1).
$$

Using the transformation $p = 1 - e^{-\lambda}$, we obtain the density
$$
f_P(p) = \theta (1-p)^{\theta - 1}, \qquad 0 < p < 1,
$$ 

so the outbreak-probability random variable 

$$
P \sim \mathrm{Beta}(1,\theta).
$$

Key properties:

-   Mean outbreak probability $$
    p_{\mathrm{mean}} = \mathbb{E}[P] = \frac{1}{1+\theta}.
    $$

-   If $\theta < 1$: mass is concentrated near $p = 1$ (many high-risk
    populations).

-   If $\theta = 1$: $P \sim \mathrm{Uniform}(0,1)$.

-   If $\theta > 1$: risks are skewed toward 0.

We treat $p_i$ as i.i.d. draws from $\mathrm{Beta}(1,\theta)$.

### Tail selection under perfect targeting ($\rho=1$)

Under perfect ranking, populations can be ordered by their outbreak
probabilities $p_i$ from highest to lowest.

Suppose a fraction $$
q = f_{\mathrm{pre}} = \alpha f
$$ of populations is vaccinated pre-emptively. This corresponds to
vaccinating the top $q$ fraction of the risk distribution.

### Risk cutoff associated with vaccinating fraction $q$

Define the cutoff $p_{\mathrm{cut}}(q)$ as the unique value satisfying
$$
\Pr(P \ge p_{\mathrm{cut}}(q)) = q.
$$ $p_{\mathrm{cut}}(q)$ is the minimum outbreak probability required to
be included among the top $q$ populations. It is a deterministic
function of $q$.

For $P \sim \mathrm{Beta}(1,\theta)$,

$$
\Pr(P \ge t) = (1-t)^\theta.
$$

Thus, 
$$
q = (1 - p_{\mathrm{cut}}(q))^\theta
\quad\Longrightarrow\quad
p_{\mathrm{cut}}(q) = 1 - q^{1/\theta}.
$$

### Mean outbreak probability in the pre-emptive (top-risk) group

Define 
$$
p_{\mathrm{pre}}(q) = \mathbb{E}[P \mid P \ge p_{\mathrm{cut}}(q)].
$$

Direct calculation yields 

$$
p_{\mathrm{pre}}(q)
= 1 - \frac{\theta}{\theta + 1}\, q^{1/\theta},
\qquad 0 < q \le 1.
$$

Checks:

-   If $q = 1$: $$
    p_{\mathrm{pre}}(1) = \frac{1}{1+\theta} = p_{\mathrm{mean}}.
    $$

-   As $q \to 0$: $$
    p_{\mathrm{pre}}(q) \to 1.
    $$

### Mean outbreak probability in the remaining group

Let 

$$
p_{\mathrm{rem}}(q) = \mathbb{E}[P \mid P < p_{\mathrm{cut}}(q)].
$$

Using the law of total expectation: 
$$
p_{\mathrm{mean}}
= q\,p_{\mathrm{pre}}(q)
+ (1-q)\,p_{\mathrm{rem}}(q),
$$ 

so

$$
p_{\mathrm{rem}}(q)
= \frac{p_{\mathrm{mean}} - q\,p_{\mathrm{pre}}(q)}{1-q}.
$$

Substituting $p_{\mathrm{mean}} = 1/(\theta+1)$ and the expression above
for $p_{\mathrm{pre}}(q)$ gives

$$
p_{\mathrm{rem}}(q)
= 
\frac{
\dfrac{1}{\theta+1}
- q 
+ \dfrac{\theta}{\theta+1} q^{1 + 1/\theta}
}{1 - q}.
$$

Using $q = f_{\mathrm{pre}} = \alpha f$, we write 
$$
p_{\mathrm{pre}}(\alpha f)
= 1 - \frac{\theta}{\theta+1}(\alpha f)^{1/\theta},
$$

$$
p_{\mathrm{rem}}(\alpha f)
=
\frac{
\dfrac{1}{\theta+1}
- \alpha f
+ \dfrac{\theta}{\theta+1} (\alpha f)^{1 + 1/\theta}
}
{1 - \alpha f}.
$$

### Mixed-strategy cost

#### Pre-emptive group

Normalized expected cost:

$$
c_{\mathrm{pre}}^{(n)}(\alpha) = \alpha f [1 + p_{\mathrm{pre}}(\alpha f)(1-\nu)R].
$$

#### Remaining group

Fraction:

$$
1 - f_{\mathrm{pre}} = 1 - \alpha f.
$$

Mean outbreak probability:

$$
p' = p_{\mathrm{rem}}(\alpha f).
$$

Reactive capacity: 
$$
f_{\mathrm{react}} = (1-\alpha)f.
$$

Effective capacity per remaining population: 

$$
f' = \frac{f_{\mathrm{react}}}{1 - f_{\mathrm{pre}}}
= \frac{(1-\alpha)f}{1 - \alpha f}.
$$

### Reactive-limited remaining group ($f' < p'$)

$$
c_{\mathrm{rem}}^{(n)}(p',f')
= f' + \bigl(p' - fr' \bigr)R.
$$

Total cost: 
$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= f + R\Bigl[(1-\alpha f)p' - (1-\alpha)f r \Bigr].
$$

### Reactive-rich remaining group ($f' \ge p'$)

$$
c_{\mathrm{rem}}^{(n)}(p',f')
= p'\,\bigl[1 + (1-r)R\bigr].
$$

$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= 
\alpha f
+ (1-\alpha f)\,p'\,\bigl[1 + (1-r)R\bigr].
$$

Unlike the equal-risk case, $p'$ is nonlinear, so
$c_{\mathrm{mixed}}^{(n)}(\alpha)$ is not piecewise-linear, and no
closed-form optimal $\alpha^*$ exists.

We therefore compute $\alpha^*$ by 1D minimization: $$
\alpha^* = 
\arg\min_{\alpha\in[0,1]} c_{\mathrm{mixed}}^{(n)}(\alpha).
$$

## Imperfect Targeting

We model imperfect targeting using a noisy prioritization score, such
that the targeting parameter $\rho$ retains its literal interpretation
as a rank correlation between true outbreak risk and the score used for
prioritization. We allocate a fraction $q=\alpha f$ of total capacity to
pre-emptive vaccination and reserve the remainder $(1-\alpha)f$ for
reactive campaigns. Under heterogeneous risk and imperfect targeting,
the pre-emptively vaccinated set is defined by ranking populations by a
noisy score $S=\Lambda+\varepsilon$ that has Spearman's rank correlation
$\rho$ with the true hazard $\Lambda$. This induces an
$\alpha$-dependent remaining-group mean outbreak probability
$p' = p_{\mathrm{rem}}(\alpha f,\rho)$, which is generally nonlinear in
$\alpha$. Conditional on $p'$, the remaining group behaves like an
equal-risk subproblem with effective reactive capacity
$f'=(1-\alpha)f/(1-\alpha f)$, yielding reactive-rich and
reactive-limited regimes depending on whether $f'\ge p'$ or $f'<p'$.
Because $p'$ varies with $\alpha$, the mixed-strategy cost
$c_{\mathrm{mix}}^{(n)}(\alpha)$ is not affine, so $\alpha^*$ is
obtained by one-dimensional numerical minimization.

### Latent outbreak risk

Each population $i$ has a latent outbreak hazard

$$
\Lambda_i \sim \mathrm{Exponential}(\theta), \qquad \theta > 0.
$$

The outbreak probability for population $i$ is

$$
P_i = 1 - e^{-\Lambda_i}, \qquad P_i \in (0,1).
$$

Marginally,

$$
P \sim \mathrm{Beta}(1,\theta),
$$

with mean outbreak probability

$$
p_{\mathrm{mean}} = \mathbb{E}[P] = \frac{1}{1+\theta}.
$$

Because $P$ is a strictly increasing function of $\Lambda$, ranking
populations by $P$ or by $\Lambda$ is equivalent.

### Noisy prioritization score and definition of $\rho$

True outbreak risk is not directly observed. Instead, populations are
ranked according to a noisy score

$$
S_i = \Lambda_i + \varepsilon_i,
$$

where

$$
\varepsilon_i \stackrel{i.i.d.}{\sim} \mathcal{N}(0,\sigma^2),
\qquad
\varepsilon_i \perp \Lambda_i.
$$ Targeting accuracy is defined as the rank correlation

$$
\rho \equiv \mathrm{corr}_{\mathrm{rank}}(\Lambda, S),
$$

where $\mathrm{corr}_{\mathrm{rank}}(\cdot,\cdot)$ denotes Spearman’s
rank correlation.

-   $\sigma = 0$ implies $\rho = 1$ (perfect ranking).
-   $\sigma \to \infty$ implies $\rho = 0$ (random ranking).

For exponential $\Lambda$ and additive Gaussian noise, the mapping
$\sigma \mapsto \rho$ is monotone but does not admit a closed-form
expression. In practice, $\sigma(\rho)$ is obtained numerically and
treated as known.

### Selection rule for pre-emptive vaccination

Let

$$
q = f_{\mathrm{pre}} = \alpha f
$$

denote the fraction of populations vaccinated pre-emptively.

Populations are ranked by the score $S$, and the pre-emptive group
consists of those satisfying

$$
S \ge s_{\mathrm{cut}}(q),
$$

where the score cutoff $s_{\mathrm{cut}}(q)$ is defined implicitly by

$$
\Pr(S \ge s_{\mathrm{cut}}(q)) = q.
$$

Since $S = \Lambda + \varepsilon$, we have

$$
\Pr(S \ge s)
=
\mathbb{E}\!\left[
1 - \Phi\!\left(\frac{s-\Lambda}{\sigma}\right)
\right],
\qquad
\Lambda \sim \mathrm{Exponential}(\theta),
$$

where $\Phi(\cdot)$ denotes the standard normal CDF. The cutoff
$s_{\mathrm{cut}}(q)$ is obtained by solving this equation for a given
$q$.

### Mean outbreak probability in the pre-emptive group

The mean outbreak probability among pre-emptively vaccinated populations
is

$$
p_{\mathrm{pre}}(q,\sigma)
=
\mathbb{E}[P \mid S \ge s_{\mathrm{cut}}(q)]
=
\mathbb{E}[1 - e^{-\Lambda} \mid S \ge s_{\mathrm{cut}}(q)].
$$

Using Bayes’ rule, this can be written as

$$
p_{\mathrm{pre}}(q,\sigma)
=
\frac{
\mathbb{E}\!\left[
(1 - e^{-\Lambda})
\left\{
1 - \Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right\}
\right]
}{
\mathbb{E}\!\left[
1 - \Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right]
}.
$$

By construction, the denominator equals $q$, so

$$
p_{\mathrm{pre}}(q,\sigma)
=
\frac{1}{q}
\mathbb{E}\!\left[
(1 - e^{-\Lambda})
\left\{
1 - \Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right\}
\right].
$$

### Mean outbreak probability in the remaining group

The mean outbreak probability among the remaining populations is

$$
p_{\mathrm{rem}}(q,\sigma)
=
\mathbb{E}[P \mid S < s_{\mathrm{cut}}(q)].
$$

Equivalently,

$$
p_{\mathrm{rem}}(q,\sigma)
=
\frac{1}{1-q}
\mathbb{E}\!\left[
(1 - e^{-\Lambda})
\Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right].
$$

By construction, the overall mean is preserved:

$$
q\,p_{\mathrm{pre}}(q,\sigma)
+
(1-q)\,p_{\mathrm{rem}}(q,\sigma)
=
p_{\mathrm{mean}}.
$$

#### Effective Reactive Capacity

Among the remaining fraction $1-q = 1-\alpha f$ of populations:

$$
f_{\mathrm{react}} = (1-\alpha)f,
\qquad
f' = \frac{f_{\mathrm{react}}}{1-q}
= \frac{(1-\alpha)f}{1-\alpha f}.
$$

The remaining group behaves like an equal-risk subproblem with outbreak
probability $p'$ and effective capacity $f'$.

## Step 5: Remaining-Group Cost Regimes

Two regimes arise:

### Reactive-rich remaining group ($f' \ge p'$)

$$
c_{\mathrm{rem,per}} = p'\,[1 + (1-r)R].
$$

### Reactive-limited remaining group ($f' < p'$)

$$
c_{\mathrm{rem,per}} = f' + (p' - f'r)R.
$$

#### Total Mixed-Strategy Cost

The normalized expected cost per population is $$
c_{\mathrm{mix}}^{(n)}(\alpha)
= q [1 + p_{\mathrm{pre}}(q)(1-\nu)R] + (1-q)\,c_{\mathrm{rem,per}},
$$ where $q = \alpha f$.

Because $p'$ varies with $\alpha$, the function
$c_{\mathrm{mix}}^{(n)}(\alpha)$ is generally **nonlinear**, unlike the
piecewise-linear form in the equal-risk model.

#### Determination of the Optimal Pre-emptive Fraction

The optimal allocation is obtained by one-dimensional minimization: $$
\alpha^*
=
\arg\min_{\alpha \in [0,1]}
c_{\mathrm{mix}}^{(n)}(\alpha).
$$

This replaces the closed-form corner/kink solution available in the
equal-risk case.

### Visualization

#### Core simulation utilities

#### Core simulation utilities

Functions `sim_lambda_P`, `spearman_rho_given_sigma`, `calibrate_sigma_for_rho`, `score_cutoff`, and `estimate_pre_rem_means` are defined in `R/analytic_utils.R`.


#### Mixed cost and optimization over $\alpha$

#### Mixed cost and optimization over $\alpha$

Functions `cost_mix_heterorisk` and `opt_alpha_heterorisk` are defined in `R/analytic_utils.R`.


Plot 1 — cost profile $c_{\mathrm{mix}}^{(n)}(\alpha)$ with $\alpha^*$

```{r}
# ---- choose one scenario ----
f_val <- 0.5
r_val <- 0.4
R_val <- 5
p_mean <- 0.3
theta <- 1 / p_mean - 1
rho_val <- 0.6

# ---- simulate latent risks once (large M helps smooth curves) ----
M <- 1000
# M <- 200000
sim <- sim_lambda_P(M = M, theta = theta, seed = 1)
lambda <- sim$lambda
P <- sim$P

opt <- opt_alpha_heterorisk(
    f = f_val, r = r_val, R = R_val,
    theta = theta, rho = rho_val,
    lambda = lambda, P = P,
    nu = 1,
    grid_len = 401
)

df <- data.frame(alpha = opt$alpha_grid, cost = opt$cost_grid)
alpha_star <- opt$alpha_star

ggplot(df, aes(x = alpha, y = cost)) +
    geom_line(linewidth = 1) +
    geom_vline(
        xintercept = alpha_star,
        linetype = "dashed", color = "firebrick", linewidth = 0.9
    ) +
    labs(
        title = bquote(italic(p)[mean] == .(p_mean) ~ "," ~
            italic(r) == .(r_val) ~ "," ~
            italic(R) == .(R_val) ~ "," ~
            italic(f) == .(f_val) ~ "," ~
            italic(rho) == .(rho_val)),
        x = expression("Fraction of capacity pre-emptive " ~ italic(alpha)),
        y = expression("Normalized per-population expected cost " ~ italic(c)[mix]^(italic(n)))
    ) +
    theme_light()
```

Plot 2 — $\alpha^*$ vs $r$ (fixed $R,f,p_{\mathrm{mean}},\rho$)

```{r}
r_grid <- seq(0, 1, by = 0.05)

alpha_star_vec <- sapply(r_grid, function(r_i) {
    opt_alpha_heterorisk(
        f = f_val, r = r_i, R = R_val,
        theta = theta, rho = rho_val,
        lambda = lambda, P = P,
        nu = 1,
        grid_len = 301
    )$alpha_star
})

df_ar <- data.frame(r = r_grid, alpha_star = alpha_star_vec)

ggplot(df_ar, aes(x = r, y = alpha_star)) +
    geom_line(linewidth = 1) +
    coord_cartesian(ylim = c(0, 1)) +
    labs(
        title = bquote(italic(p)[mean] == .(p_mean) ~ "," ~
            italic(R) == .(R_val) ~ "," ~
            italic(f) == .(f_val) ~ "," ~
            italic(rho) == .(rho_val)),
        x = expression("Reactive effectiveness " ~ italic(r)),
        y = expression("Optimal pre-emptive fraction " ~
            italic(alpha)^"*")
    ) +
    theme_light()
```

Plot 3 — Heatmap of $\alpha^*(R,r)$ (fixed $f,p_{\mathrm{mean}},\rho$)

```{r}
r_vals <- seq(0, 1, length.out = 20)
R_vals <- 10^seq(-2, 2, length.out = 20)

grid <- expand.grid(r = r_vals, R = R_vals)

grid$alpha_star <- mapply(function(r_i, R_i) {
    opt_alpha_heterorisk(
        f = f_val, r = r_i, R = R_i,
        theta = theta, rho = rho_val,
        lambda = lambda, P = P,
        nu = 1,
        grid_len = 201
    )$alpha_star
}, grid$R, grid$r)

ggplot(grid, aes(x = r, y = R, fill = alpha_star)) +
    geom_tile() +
    scale_y_log10() +
    # Colorbar
    scale_fill_viridis_c(
        option = "viridis",
        name = expression(italic(alpha)^"*")
    ) +
    labs(
        title = bquote(italic(p)[mean] == .(p_mean) ~ "," ~
            italic(f) == .(f_val) ~ "," ~
            italic(rho) == .(rho_val)),
        x = expression(italic(r)),
        y = expression(italic(R)),
        fill = expression(italic(alpha)^"*")
    ) +
    theme_light()

```

Plot 4 — $\alpha^*$ vs $\rho$

```{r}
f_val <- 0.5
r_val <- 0.6
R_val <- 20
p_mean <- 0.3
theta <- 1 / p_mean - 1

# ---- Simulate latent risks once ----
# M <- 200000
M <- 1000
sim <- sim_lambda_P(M = M, theta = theta, seed = 1)
lambda <- sim$lambda
P <- sim$P

# ---- Compute alpha* across rho ----
rho_grid <- seq(0, 1, by = 0.05)

alpha_star_vec <- sapply(rho_grid, function(rho_i) {
    opt_alpha_heterorisk(
        f = f_val, r = r_val, R = R_val, theta = theta,
        rho = rho_i, lambda = lambda, P = P,
        nu = 1,
        grid_len = 401
    )$alpha_star
})

df_rho <- data.frame(rho = rho_grid, alpha_star = alpha_star_vec)

# ---- Plot ----
ggplot(df_rho, aes(x = rho, y = alpha_star)) +
    geom_line(linewidth = 1) +
    coord_cartesian(ylim = c(0, 1)) +
    labs(
        title = bquote(italic(p)[mean] == .(p_mean) ~ "," ~
            italic(r) == .(r_val) ~ "," ~
            italic(R) == .(R_val) ~ "," ~
            italic(f) == .(f_val)),
        x = expression("Targeting accuracy (Spearman rank correlation) " ~ italic(rho)),
        y = expression("Optimal pre-emptive fraction " ~ italic(alpha)^"*")
    ) +
    theme_light()
```

Plot 5 — $c_{\mathrm{mix}}^{(n)}$, $\alpha^*$ vs $\rho$

```{r}
f_val <- 0.5
r_val <- 0.4
R_val <- 5
p_mean <- 0.3
theta <- 1 / p_mean - 1
rho_vals <- c(0.2, 0.6, 1.0) # <- three facets (edit as you like)

# ---- simulate latent risks once (keep fixed across rho for fair comparison) ----

M <- 1000
# M <- 200000
sim <- sim_lambda_P(M = M, theta = theta, seed = 1)
lambda <- sim$lambda
P <- sim$P

# ---- compute cost profile for each rho ----

df_all <- purrr::map_dfr(rho_vals, function(rho_val) {
    opt <- opt_alpha_heterorisk(
        f = f_val,
        r = r_val,
        R = R_val,
        theta = theta,
        rho = rho_val,
        lambda = lambda,
        P = P,
        nu = 1,
        grid_len = 401
    )

    data.frame(
        alpha      = opt$alpha_grid,
        cost       = opt$cost_grid,
        rho        = rho_val,
        alpha_star = opt$alpha_star
    )
})

# ---- one vline per facet ----

df_vline <- df_all |>
    distinct(rho, alpha_star) |>
    mutate(
        rho_lab = factor(
            rho,
            levels = rho_vals,
            labels = paste0("italic(rho)==", rho_vals)
        )
    )

# ---- facet labels ----
df_all <- df_all |>
    mutate(
        rho_lab = factor(
            rho,
            levels = rho_vals,
            labels = paste0("italic(rho)==", rho_vals)
        )
    )

# ---- plot ----
ggplot(df_all, aes(x = alpha, y = cost)) +
    geom_line(linewidth = 1) +
    geom_vline(
        data = df_vline,
        aes(xintercept = alpha_star),
        linetype = "dashed",
        color = "firebrick",
        linewidth = 0.9
    ) +
    facet_wrap(~rho_lab, labeller = label_parsed) +
    labs(
        title = bquote(
            italic(p)[mean] == .(p_mean) ~ "," ~
                italic(r) == .(r_val) ~ "," ~
                italic(R) == .(R_val) ~ "," ~
                italic(f) == .(f_val)
        ),
        x = expression("Fraction of capacity pre-emptive " ~ italic(alpha)),
        y = expression("Normalized per-population expected cost " ~
            italic(c)[mix]^(italic(n)))
    ) +
    theme_light()

```

# Spatially correlated outbreak risks and spillover

This section presents a description of the outbreak and vaccination model. The exposition is organized to move from baseline risk, to spillover, to vaccination, and finally to expected costs. The framework is static (one-year) and designed to balance realism with analytical transparency.

---

## Notation and setup

We consider a population divided into $n$ spatial units (grid cells), indexed by $i \in \{1,\dots,n\}$.

- Neighborhood of cell $i$: $\mathcal{N}(i)$ (e.g., rook or queen adjacency)
- Adjacency indicator: $A_{ij} = \mathbf{1}\{j \in \mathcal{N}(i)\}$
- Primary outbreak indicator: $Y_i^{(0)} \in \{0,1\}$
- Secondary (spillover) outbreak indicator: $Y_i^{(1)} \in \{0,1\}$
- Final outbreak indicator: $Y_i \in \{0,1\}$
- Baseline outbreak probability: $p_i \in (0,1)$
- Spillover strength parameter: $\eta \in [0,1]$

We distinguish between **primary outbreaks**, driven by baseline vulnerability, and **secondary outbreaks**, arising through local spillover from neighboring primary outbreaks.

---

## Spatially correlated baseline outbreak risk

Each cell $i$ has a baseline probability $p_i$ of experiencing a primary outbreak, representing environmental, infrastructural, and socio-demographic vulnerability prior to local transmission.

Baseline risks are generated from a latent spatial field,
$$
Z \sim \mathcal{N}(0, \Sigma(\phi)), \qquad
p_i = \mathrm{logit}^{-1}(\mu + Z_i),
$$
where $\Sigma(\phi)$ encodes spatial dependence and $\phi$ controls the strength and range of correlation. The intercept $\mu$ sets the overall mean outbreak probability.

Conditional on $p=(p_1,\dots,p_n)$, primary outbreaks occur independently:
$$
Y_i^{(0)} \mid p_i \sim \mathrm{Bernoulli}(p_i), \qquad i=1,\dots,n.
$$
---

## Spillover-driven secondary outbreaks

Let
$$
K_i = \sum_{j \in \mathcal{N}(i)} Y_j^{(0)}
$$
denote the number of neighboring primary outbreaks.

Spillover is modeled using a monotone dose–response function,
$$
h(K_i) = 1 - (1-\eta)^{K_i},
$$
which satisfies $h(0)=0$ and increases smoothly with $K_i$.

Conditional on $K_i$,
$$
Y_i^{(1)} \mid K_i \sim \mathrm{Bernoulli}\!\left(h(K_i)\right).
$$

The final outbreak indicator is
$$
Y_i = 1 - (1 - Y_i^{(0)})(1 - Y_i^{(1)}),
$$
so that
$$
\Pr(Y_i = 1 \mid p, K_i)
= p_i + (1-p_i)\,h(K_i).
$$

This reduced-form representation captures spatial amplification of outbreak risk without explicitly modeling transmission dynamics.

Secondary outbreaks do not generate further spillover; this prevents epidemic cascades and keeps the model analytically tractable.
---

## Vaccination effects

Let $V_i \in \{0,1\}$ indicate whether cell $i$ is vaccinated pre-emptively.

Vaccination modifies both baseline risk and spillover susceptibility:

- **Baseline risk reduction**
$$
p_i(V_i) = (1-\nu V_i)\,p_i,
$$
where $\nu \in [0,1]$ is effectiveness against primary outbreaks.

- **Spillover susceptibility reduction**
$$
\eta(V_i) = (1-\kappa V_i)\,\eta,
$$
where $\kappa \in [0,1]$ captures protection against secondary spread.

These modified quantities are substituted directly into the outbreak equations.

---

## Expected outbreak probability (cell level)

Conditioning on baseline risks $p$, the expected outbreak probability in cell $i$ is
$$
\mathbb{E}[Y_i \mid p]
=
p_i + (1-p_i)\left(1-\prod_{j\in\mathcal{N}(i)}(1-\eta p_j)\right).
$$

Spillover therefore depends on the joint configuration of neighboring baseline risks, not merely their average.

Vaccination does not reduce infectiousness of neighbors (i.e., no outward spillover reduction), only susceptibility.
---

## Expected outbreak count

Let  
$$
N_{\mathrm{out}} = \sum_{i=1}^n Y_i
$$
denote the total number of outbreak cells.

Conditional on $p$,
$$
\mathbb{E}[N_{\mathrm{out}} \mid p]
=
\sum_{i=1}^n
\left[
p_i + (1-p_i)\left(1-\prod_{j\in\mathcal{N}(i)}(1-\eta p_j)\right)
\right].
$$

When $p$ itself is random and spatially correlated,
$$
\mathbb{E}[N_{\mathrm{out}}]
=
\mathbb{E}_p\!\left[\mathbb{E}[N_{\mathrm{out}} \mid p]\right].
$$
This quantity does not admit a closed form and is evaluated via Monte Carlo simulation.

---

## Expected total cost under a mixed vaccination strategy

### Decisions and constraints

- Pre-emptive vaccination: $V_i \in \{0,1\}$ (chosen before outbreaks)
- Reactive vaccination: $R_i \in \{0,1\}$ (chosen after observing outbreaks), with $R_i \le Y_i$
- Vaccine cost per cell: $C_V$
- Unmitigated outbreak cost per cell: $C_I$
- Cost ratio: $R = C_I/C_V$
- Reactive effectiveness: $r \in [0,1]$

Total vaccination capacity allows vaccination of a fraction $f$ of cells. A fraction $\alpha$ is allocated pre-emptively, leaving reactive capacity
$$
B_{\mathrm{re}} = (1-\alpha) f n.
$$

Reactive vaccination is subject to the followig rule,
$$
\sum_{i=1}^n R_i = \min(N_{\mathrm{out}}, B_{\mathrm{re}}).
$$

---

### Expected cost

Vaccination cost:
$$
C_{vacc}
=
C_V\sum_{i=1}^n V_i
+
C_V\,\mathbb{E}\!\left[\sum_{i=1}^n R_i\right].
$$

Outbreak cost:
$$
\mathbb{E}[C_{out}]
=
C_I\left(
\mathbb{E}[N_{out}]
-
r\,\mathbb{E}\!\left[\sum_{i=1}^n R_i\right]
\right).
$$

Total expected cost:
$$
\mathbb{E}[C_{\mathrm{total}}]
=
C_V\sum_{i=1}^n V_i
+
C_I\,\mathbb{E}[N_{\mathrm{out}}]
+
(C_V-rC_I)\,
\mathbb{E}\!\left[\min(N_{\mathrm{out}}, B_{\mathrm{re}})\right].
$$

---

## Role of spillover

Spillover influences expected costs only through the distribution of $N_{\mathrm{out}}$. There is no direct spillover term in the cost function; all effects are mediated by changes in outbreak occurrence.

---

## Simulation workflow

Expected costs are evaluated by Monte Carlo simulation:

1. Draw a spatially correlated risk field $p$
2. Sample primary outbreaks $Y^{(0)}$
3. Compute $K_i$ and sample secondary outbreaks $Y^{(1)}$
4. Construct final outbreaks $Y$ and $N_{\mathrm{out}}$
5. Apply reactive allocation
6. Compute realized costs and average across replicates

---

### Mixed strategy simulation

```{r}
simulate_patch_spillover <- function(p_true, score_cell,
                                     adj, patches, patch_df,
                                     alpha, f, R, r,
                                     eta = 0.2, nu = 0, kappa = 0,
                                     seed = NULL) {
    if (!is.null(seed)) set.seed(seed)

    stopifnot(
        alpha >= 0, alpha <= 1, f > 0, f <= 1, R >= 0, r >= 0, r <= 1,
        is.numeric(p_true), all(p_true > 0), all(p_true < 1),
        is.numeric(score_cell), length(score_cell) == length(p_true)
    )

    patches <- patches[!vapply(patches, is.null, logical(1))]
    Kpatch <- length(patches)
    stopifnot(nrow(patch_df) == Kpatch)

    n <- length(p_true)

    # Budgets in number of CELLS
    B_pre <- alpha * f * n
    B_react <- (1 - alpha) * f * n
    # -------------------------------------------------
    # 1. Pre-emptive vaccination (PATCH level, score-based)
    # -------------------------------------------------

    pre <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
    pre_vax_patch <- as.logical(pre$pre_vax)
    used_pre <- as.numeric(pre$used)

    V_pre_cell <- rep(FALSE, n)
    if (any(pre_vax_patch)) {
        for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
    }

    # -------------------------------------------------
    # 2. Outbreak realization (CELL level, true risk)
    # -------------------------------------------------
    outb <- simulate_outbreak_spillover(
        p = p_true,
        adj = adj,
        vax = V_pre_cell,
        eta = eta,
        nu = nu,
        kappa = kappa
    )

    Y_cell <- as.logical(outb$Y)
    Y0_cell <- outb$Y0
    Y1_cell <- outb$Y1

    # -------------------------------------------------
    # 3. Reactive vaccination (CELL level, observation-only)
    # -------------------------------------------------

    outbreak_cells <- which(Y_cell & !V_pre_cell)

    used_react <- min(length(outbreak_cells), floor(B_react))
    react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

    V_react_cell <- rep(FALSE, n)
    if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

    V_any_cell <- V_pre_cell | V_react_cell

    # -------------------------------------------------
    # 4. Costs (CELL level)
    # -------------------------------------------------

    vax_cost_total <- used_pre + used_react

    outbreak_cost <- R * sum(
        as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1)
    )

    total_cost <- vax_cost_total + outbreak_cost

    # -------------------------------------------------
    # 5. Derived PATCH summaries (reporting only
    # -------------------------------------------------

    outbreak_patch <- vapply(
        seq_len(Kpatch),
        function(k) any(Y_cell[patches[[k]]]),
        logical(1)
    )

    react_vax_patch <- vapply(
        seq_len(Kpatch),
        function(k) any(V_react_cell[patches[[k]]]),
        logical(1)
    )

    list(
        total_cost = total_cost,
        vax_cost = vax_cost_total,
        outbreak_cost = outbreak_cost,
        # Cell-level (primary outputs)
        V_pre_cell = V_pre_cell,
        V_react_cell = V_react_cell,
        V_any_cell = V_any_cell,
        Y_cell = Y_cell,
        Y0_cell = Y0_cell,
        Y1_cell = Y1_cell,

        # Patch-level (derived)
        pre_vax_patch = pre_vax_patch,
        react_vax_patch = react_vax_patch,
        outbreak_patch = outbreak_patch,

        # Bookkeeping
        used_pre = used_pre,
        used_react = used_react,
        B_pre = B_pre,
        B_react = B_react
    )
}

```

---

### Monte Carlo evaluation and optimization
```{r}
estimate_cost_alpha_patch_spillover <-
    function(p_true, score_cell, adj, patches, patch_df,
             alpha, f, R, r, eta = 0.2, nu = 0, kappa = 0,
             n_mc = 2000, seed = NULL) {
        if (!is.null(seed)) set.seed(seed)

        n <- length(p_true)
        B_pre <- alpha * f * n
        B_react <- (1 - alpha) * f * n

        # Pre-emptive allocation (deterministic given inputs)
        pre <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
        pre_vax_patch <- as.logical(pre$pre_vax)
        used_pre <- as.numeric(pre$used)

        V_pre_cell <- rep(FALSE, n)
        if (any(pre_vax_patch)) {
            # Fix: Ensure patches are valid indices
            for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
        }

        costs <- replicate(n_mc, {
            # Outbreak
            outb <- simulate_outbreak_spillover(
                p = p_true,
                adj = adj,
                vax = V_pre_cell,
                eta = eta,
                nu = nu,
                kappa = kappa
            )
            Y_cell <- as.logical(outb$Y)

            # Reactive
            outbreak_cells <- which(Y_cell & !V_pre_cell)
            used_react <- min(length(outbreak_cells), floor(B_react))

            V_react_cell <- rep(FALSE, n)
            if (used_react > 0) {
                react_cells <- outbreak_cells[seq_len(used_react)]
                V_react_cell[react_cells] <- TRUE
            }

            # Cost
            vax_cost_total <- used_pre + used_react
            outbreak_cost <- R * sum(as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1))

            vax_cost_total + outbreak_cost
        })
        c(mean = mean(costs), sd = sd(costs))
    }
```

```{r}
alpha_star_patch_grid_spillover <-
    function(p_true, score_cell, adj, patches, patch_df,
             f, R, r, eta = 0.2, nu = 0, kappa = 0,
             alpha_grid = seq(0, 1, by = 0.05), n_mc = 2000, seed = NULL) {
        res <- data.frame(alpha = alpha_grid, mean_cost = NA_real_)

        for (i in seq_along(alpha_grid)) {
            res$mean_cost[i] <- estimate_cost_alpha_patch_spillover(
                p_true = p_true, score_cell = score_cell,
                adj = adj, patches = patches, patch_df = patch_df,
                alpha = alpha_grid[i], f = f, R = R, r = r,
                eta = eta, nu = nu, kappa = kappa,
                n_mc = n_mc, seed = seed
            )["mean"]
        }

        list(alpha_star = res$alpha[which.min(res$mean_cost)], grid = res)
    }
```

---

# Example run

```{r}
nx <- 25
ny <- 20
rho0_val <- 0.6
ell_val <- 4
theta_val <- 3

rho_target_val <- 0.7
n_seeds_val <- 10
patch_size_val <- 40

alpha_val <- 0.5
f_val <- 0.3
R_val <- 5
r_val <- 0.6
eta_val <- 0.8
nu_val <- 0.9
kappa_val <- 0.8

n_mc <- 1000

coords <- as.matrix(expand.grid(x = 1:nx, y = 1:ny))

sim <- spatial_beta_risk(coords,
    theta = theta_val,
    rho0 = rho0_val, ell = ell_val
)
p_true <- sim$p

rank_out <- make_ranking(p_true, rho_target = rho_target_val)
score_cell <- rank_out$score

adj <- make_adj(coords, type = "distance", d0 = 1.01)

patch_out <- make_patches(score_cell,
    adj,
    n_seeds = n_seeds_val,
    patch_size = patch_size_val
)
patches <- patch_out$patches
patches <- patches[!vapply(patches, is.null, logical(1))]

patch_df <- summarize_patches(list(score = score_cell, patches = patches))

opt <- alpha_star_patch_grid_spillover(
    p_true = p_true,
    score_cell = score_cell,
    adj = adj,
    patches = patches,
    patch_df = patch_df,
    f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    alpha_grid = seq(0, 1, by = 0.02),
    n_mc = 2000,
    seed = 1
)
opt$alpha_star

ggplot(opt$grid, aes(alpha, mean_cost)) +
    geom_line() +
    theme_light()
```


# Figures

## Figure 1. Spatially correlated risks $p_i$

```{r}
df_risk <- data.frame(
    x = coords[, 1],
    y = coords[, 2],
    p = p_true
)

ggplot(df_risk, aes(x = x, y = y, fill = p)) +
    geom_tile() +
    coord_equal() +
    labs(
        title = expression("Spatially correlated risks " * italic(p)[i]),
        x = NULL, y = NULL, fill = "p_i"
    ) +
    theme_minimal(base_size = 12)
```

## Figure 2. Imperfect risk score vs true risk

```{r}
df_score <- data.frame(p = p_true, score = score_cell)
ggplot(df_score, aes(x = p, y = score)) +
    geom_point(alpha = 0.4) +
    labs(
        title = paste0(
            "Imperfect score vs true risk (Spearman rho = ",
            round(rank_out$rho_achieved, 2), ")"
        ),
        x = expression(italic(p)[i]), y = "score_i"
    ) +
    theme_light()
```

## Figure 3. Patch map

```{r, fig.width=7, fig.height=4.5}
patch_id_vec <- patch_out$patch_id
df_patchmap <- data.frame(
    x = coords[, 1],
    y = coords[, 2],
    patch = factor(patch_id_vec)
)

ggplot(df_patchmap, aes(x = x, y = y, fill = patch)) +
    geom_tile() +
    coord_equal() +
    guides(fill = "none") +
    labs(
        title = "Patches (contiguous groups grown from high-score seeds)",
        x = NULL, y = NULL
    ) +
    theme_minimal(base_size = 12)
```

## Figure 4.Simulated pre-emptive vs reactive vs outbreaks

```{r}
# Budgets (calculated here for this specific realization)
n <- length(p_true)
B_pre <- floor(alpha_val * f_val * n)
B_react <- floor((1 - alpha_val) * f_val * n)
# 1. Pre-emptive allocation
pre_alloc <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
pre_vax_patch <- as.logical(pre_alloc$pre_vax)
V_pre_cell <- rep(FALSE, n)
if (any(pre_vax_patch)) {
    for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
}
# 2. Outbreak realization
outb <- simulate_outbreak_spillover(
    p = p_true,
    adj = adj,
    vax = V_pre_cell,
    eta = eta_val,
    nu = nu_val,
    kappa = kappa_val
)
Y_cell <- as.logical(outb$Y)
# 3. Reactive vaccination
outbreak_cells <- which(Y_cell & !V_pre_cell)
used_react <- min(length(outbreak_cells), B_react)
V_react_cell <- rep(FALSE, n)
if (used_react > 0) {
    react_cells <- outbreak_cells[seq_len(used_react)]
    V_react_cell[react_cells] <- TRUE
}
df_state <-
    data.frame(
        x = coords[, 1],
        y = coords[, 2],
        pre = V_pre_cell,
        react = V_react_cell,
        out = Y_cell
    ) %>%
    mutate(state = dplyr::case_when(
        out & react ~ "Outbreak + reactive",
        out & !react ~ "Outbreak (unmitigated)",
        !out & pre ~ "Pre-emptive vaccinated",
        !out & react ~ "Reactive vaccinated (no outbreak)",
        TRUE ~ "None"
    ))
ggplot(df_state, aes(x = x, y = y, fill = state)) +
    geom_tile() +
    coord_equal() +
    labs(
        title = paste0("Realization (alpha = ", alpha_val, ")"),
        x = NULL, y = NULL, fill = NULL
    ) +
    theme_light(base_size = 12)
```


## Figure 5. Cost curve across $\alpha$ and estimated $\alpha^*$

```{r, fig.width=7, fig.height=4.5}
opt <- alpha_star_patch_grid_spillover(
    p_true = p_true,
    score_cell = score_cell,
    adj = adj,
    patches = patches,
    patch_df = patch_df,
    f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    alpha_grid = seq(0, 1, by = 0.02),
    n_mc = 2000,
    seed = 1
)

ggplot(opt$grid, aes(x = alpha, y = mean_cost)) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    geom_vline(xintercept = opt$alpha_star, linetype = "dashed") +
    labs(
        title = paste0("Mean cost vs alpha (alpha* = ", opt$alpha_star, ")"),
        x = expression(alpha),
        y = "Mean cost (units of C_V)"
    ) +
    theme_light(base_size = 12)
```

---
### Experiement

Compare two alternative vaccination strategies. In Strategy A, pre-emptive vaccination occurs at the patch level after accounting for spill-over risk in addition to cell-level risk (environmental factors). In Strategy B, pre-emptive vaccination occurs at the cell level that only accounts for the cell-level risk (environmental factors). Reactive vaccination occurs at the cell level in both strategies.

```{r}


```

2) Strategy A: Cell-level pre-emptive simulator (thin wrapper)

```{r}
simulate_cell_spillover <- function(p_true, score_cell,
                                    adj,
                                    alpha, f, R, r,
                                    eta = 0.2, nu = 0, kappa = 0,
                                    seed = NULL) {
    if (!is.null(seed)) set.seed(seed)

    stopifnot(length(p_true) == length(score_cell))
    n <- length(p_true)

    # Budgets in CELLS
    B_pre <- alpha * f * n
    B_react <- (1 - alpha) * f * n

    # -------------------------------------------------
    # 1) Pre-emptive vaccination (CELL level, score-based)
    # -------------------------------------------------
    ord <- order(score_cell, decreasing = TRUE)
    used_pre <- min(floor(B_pre), n)
    pre_cells <- if (used_pre > 0) ord[seq_len(used_pre)] else integer(0)

    V_pre_cell <- rep(FALSE, n)
    if (length(pre_cells) > 0) V_pre_cell[pre_cells] <- TRUE

    # -------------------------------------------------
    # 2) Outbreak realization (CELL level, true risk)
    # -------------------------------------------------
    outb <- simulate_outbreak_spillover(
        p = p_true,
        adj = adj,
        vax = V_pre_cell,
        eta = eta,
        nu = nu,
        kappa = kappa
    )
    Y_cell <- as.logical(outb$Y)

    # -------------------------------------------------
    # 3) Reactive vaccination (CELL level, observation-only)
    # -------------------------------------------------
    outbreak_cells <- which(Y_cell & !V_pre_cell)

    used_react <- min(length(outbreak_cells), floor(B_react))
    react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

    V_react_cell <- rep(FALSE, n)
    if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

    # -------------------------------------------------
    # 4) Costs (CELL level, units of C_V)
    # -------------------------------------------------
    vax_cost_total <- used_pre + used_react

    outbreak_cost <- R * sum(
        as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1)
    )

    total_cost <- vax_cost_total + outbreak_cost

    list(
        total_cost = total_cost,
        vax_cost = vax_cost_total,
        outbreak_cost = outbreak_cost,
        V_pre_cell = V_pre_cell,
        V_react_cell = V_react_cell,
        Y_cell = Y_cell,
        used_pre = used_pre,
        used_react = used_react,
        B_pre = B_pre,
        B_react = B_react
    )
}

```

3) Strategy B: Patch-level pre-emptive, spillover-aware
We can recycle functions that we have 

- `make_patches(score, adj, ...)`
- `summarize_patches(p_true, score_cell, patches)` (uses mean score per patch)
- `allocate_preemptive_targeted(patch_df, B_pre)`
- `simulate_patch_spillover(...)` (does patch-level pre + cell-level reactive + cost)

We will feed it a spillover-aware score (derived from p_aug), while keeping outbreak generation driven by p_true.

4) Build the two strategy inputs (scores + patches)
This is the key “setup” function that you run once per scenario.
```{r}
build_strategy_objects <- function(p_true, adj,
                                   rho_cell = 0.7,
                                   rho_patch = 0.7,
                                   eta_score = 0.8,
                                   n_seeds = 10,
                                   patch_size = 40,
                                   seed_cell = 1,
                                   seed_patch = 2) {
    # ---- Strategy A score: cell-risk only (imperfect ranking of p_true)
    rank_cell <- make_ranking(p_true,
        rho_target = rho_cell,
        seed = seed_cell
    )
    score_cell <- rank_cell$score

    # ---- Strategy B score: spillover-aware (imperfect ranking of augmented risk)
    p_aug <- augment_risk_spillover(p_true, adj, eta = eta_score)
    rank_patch <- make_ranking(p_aug, rho_target = rho_patch, seed = seed_patch)
    score_spill <- rank_patch$score

    # ---- Patches built from spillover-aware score (consistent with strategy B)
    patch_out <- make_patches(score_spill, adj,
        n_seeds = n_seeds,
        patch_size = patch_size
    )
    patches <- patch_out$patches
    patches <- patches[!vapply(patches, is.null, logical(1))]
    patch_df <- summarize_patches(list(score = score_spill, patches = patches))

    list(
        # Strategy A
        score_cell = score_cell,
        rank_cell = rank_cell,

        # Strategy B
        p_aug = p_aug,
        score_spill = score_spill,
        rank_patch = rank_patch,
        patches = patches,
        patch_df = patch_df,
        patch_id = patch_out$patch_id
    )
}

```


```{r}
compare_cell_vs_patch <- function(p_true,
                                  score_cell,
                                  adj,
                                  patches, patch_df,
                                  score_spill,
                                  alpha, f, R, r,
                                  eta = 0.8, nu = 0.9, kappa = 0.8,
                                  n_mc = 1000, seed = 1) {
    set.seed(seed)
    seeds <- sample.int(1e9, n_mc)

    cost_cell <- numeric(n_mc)
    cost_patch <- numeric(n_mc)

    for (b in seq_len(n_mc)) {
        s <- seeds[b]

        A <- simulate_cell_spillover(
            p_true = p_true,
            score_cell = score_cell,
            adj = adj,
            alpha = alpha, f = f, R = R, r = r,
            eta = eta, nu = nu, kappa = kappa,
            seed = s
        )

        B <- simulate_patch_spillover(
            p_true = p_true,
            score_cell = score_spill, # used ONLY for patch targeting
            adj = adj,
            patches = patches,
            patch_df = patch_df,
            alpha = alpha, f = f, R = R, r = r,
            eta = eta, nu = nu, kappa = kappa,
            seed = s
        )

        cost_cell[b] <- A$total_cost
        cost_patch[b] <- B$total_cost
    }

    df <- data.frame(
        cost_cell = cost_cell,
        cost_patch = cost_patch,
        diff = cost_patch - cost_cell
    )

    list(
        summary = c(
            mean_cell  = mean(df$cost_cell),
            mean_patch = mean(df$cost_patch),
            mean_diff  = mean(df$diff),
            sd_diff    = sd(df$diff)
        ),
        draws = df
    )
}
```

Simulation parameters

```{r}
# --- build risks + adjacency (as you already do) ---
nx <- 25
ny <- 20
rho0_val <- 0.8
ell_val <- 20
theta_val <- 5
# rho_target_val <- 0.7
# n_seeds_val <- 10
# patch_size_val = 40

alpha_val <- 0.8
f_val <- 0.4
R_val <- 10
r_val <- 0.3
eta_val <- 0.9
nu_val <- 0.9
kappa_val <- 0.9

n_seeds_val <- 10
patch_size_val <- 2
```

Simulation
```{r}
coords <- as.matrix(expand.grid(x = 1:nx, y = 1:ny))

sim <- spatial_beta_risk(coords,
    theta = theta_val,
    rho0 = rho0_val, ell = ell_val
)
p_true <- sim$p
adj <- make_adj(coords, type = "rook") # or distance/queen

# --- strategy objects ---
obj <- build_strategy_objects(
    p_true = p_true,
    adj = adj,
    rho_cell = 0.7,
    rho_patch = 0.7,
    eta_score = 0.8,
    n_seeds = n_seeds_val,
    patch_size = patch_size_val,
    seed_cell = 1,
    seed_patch = 2
)

# --- compare at a chosen alpha ---
res <- compare_cell_vs_patch(
    p_true = p_true,
    score_cell = obj$score_cell,
    adj = adj,
    patches = obj$patches,
    patch_df = obj$patch_df,
    score_spill = obj$score_spill,
    alpha = alpha_val, f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    n_mc = 2000, seed = 1
)

res$summary

```

`allocate_preemptive_targeted()` is a greedy knapsack by patch size, but it can leave unused budget when patch sizes are chunky. That would confound a patch-size experiment (bigger patches look worse partly because you “wasted” doses).

Select best patches until you cannot add another patch without exceeding 
the budget for the pre-emptive vaccination. If leftover budget remains, top up with best remaining cells (by the same spillover-aware score) outside vaccinated cells.

This makes dose usage comparable across patch sizes.
```{r}
allocate_preemptive_patches_with_topup <- function(patch_df, patches, score_cell, B_pre, n) {
    ord <- order(patch_df$S_hat, decreasing = TRUE)

    V_pre <- rep(FALSE, n)
    used <- 0L

    # 1) take whole patches greedily
    for (k in ord) {
        m <- patch_df$m[k]
        if (used + m <= B_pre) {
            V_pre[patches[[k]]] <- TRUE
            used <- used + m
        }
    }

    # 2) top-up with best remaining cells (optional)
    leftover <- B_pre - used
    if (leftover > 0) {
        cand <- which(!V_pre)
        if (length(cand) > 0) {
            ord_cell <- cand[order(score_cell[cand], decreasing = TRUE)]
            take <- ord_cell[seq_len(min(leftover, length(ord_cell)))]
            V_pre[take] <- TRUE
            used <- used + length(take)
        }
    }

    list(V_pre_cell = V_pre, used = used)
}
```

```{r}
simulate_preemptive_by_patchsize <- function(p_true, adj,
                                             score_cell,
                                             patch_size,
                                             n_seeds,
                                             alpha, f, R, r,
                                             eta = 0.2, nu = 0, kappa = 0,
                                             topup = TRUE,
                                             seed = NULL) {
    if (!is.null(seed)) set.seed(seed)
    n <- length(p_true)

    # budgets
    B_pre <- floor(alpha * f * n)
    B_react <- floor((1 - alpha) * f * n)

    # ---- patch_size = 1 means "cell-level pre-emptive"
    if (patch_size == 1) {
        ord <- order(score_cell, decreasing = TRUE)
        pre_cells <- ord[seq_len(min(B_pre, n))]
        V_pre_cell <- rep(FALSE, n)
        V_pre_cell[pre_cells] <- TRUE
        used_pre <- sum(V_pre_cell)

        patches <- NULL
        patch_df <- NULL
    } else {
        # build patches using the SAME score_cell (spillover-aware score if you choose)
        patch_out <- make_patches(score_cell, adj,
            n_seeds = n_seeds,
            patch_size = patch_size
        )
        patches <- patch_out$patches
        patches <- patches[!vapply(patches, is.null, logical(1))]

        patch_df <- summarize_patches(list(score = score_cell, patches = patches))

        if (topup) {
            alloc <- allocate_preemptive_patches_with_topup(
                patch_df = patch_df, patches = patches,
                score_cell = score_cell, B_pre = B_pre, n = n
            )
            V_pre_cell <- alloc$V_pre_cell
            used_pre <- alloc$used
        } else {
            pre <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
            used_pre <- as.integer(pre$used)
            pre_vax_patch <- as.logical(pre$pre_vax)
            V_pre_cell <- rep(FALSE, n)
            if (any(pre_vax_patch)) {
                for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
            }
            used_pre <- sum(V_pre_cell)
        }
    }

    # ---- outbreaks (true risk + spillover; identical)
    outb <- simulate_outbreak_spillover(
        p = p_true,
        adj = adj,
        vax = V_pre_cell,
        eta = eta,
        nu = nu,
        kappa = kappa
    )
    Y_cell <- as.logical(outb$Y)

    # ---- reactive (cell-level, observation-only)
    outbreak_cells <- which(Y_cell & !V_pre_cell)
    used_react <- min(length(outbreak_cells), B_react)
    react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

    V_react_cell <- rep(FALSE, n)
    if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

    # ---- costs
    vax_cost_total <- used_pre + used_react
    outbreak_cost <- R * sum(as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1))
    total_cost <- vax_cost_total + outbreak_cost

    list(
        total_cost = total_cost,
        vax_cost = vax_cost_total,
        outbreak_cost = outbreak_cost,
        used_pre = used_pre,
        used_react = used_react,
        B_pre = B_pre,
        B_react = B_react,
        patch_size = patch_size,
        n_seeds = n_seeds
    )
}
```

```{r}
# spillover-aware risk proxy used ONLY for pre-emptive targeting
p_aug <- augment_risk_spillover(p_true, adj, eta = eta_val)

rank_out <- make_ranking(p_aug, rho_target = 0.8, seed = 1)
score_spill <- rank_out$score
```


```{r}
estimate_cost_by_patchsize <- function(p_true, adj, score_cell,
                                       patch_sizes = c(1, 2, 3, 5, 10, 20, 40),
                                       cover_mult = 2.0, # controls n_seeds as patch_size changes
                                       alpha, f, R, r,
                                       eta = 0.2, nu = 0, kappa = 0,
                                       topup = TRUE,
                                       n_mc = 1000, seed = 1) {
    n <- length(p_true)

    # choose n_seeds so candidate patch pool stays roughly comparable
    # target pool ~ cover_mult * B_pre_max where B_pre_max = f*n (alpha=1)
    B_pre_max <- floor(f * n)
    L_target <- min(cover_mult * B_pre_max, n)

    set.seed(seed)
    seeds <- sample.int(1e9, n_mc)

    res <- lapply(patch_sizes, function(ps) {
        n_seeds <- if (ps == 1) NA_integer_ else ceiling(L_target / ps)

        costs <- numeric(n_mc)
        used_pre <- numeric(n_mc)

        for (b in seq_len(n_mc)) {
            sim <- simulate_preemptive_by_patchsize(
                p_true = p_true, adj = adj,
                score_cell = score_cell,
                patch_size = ps,
                n_seeds = if (is.na(n_seeds)) 1 else n_seeds,
                alpha = alpha, f = f, R = R, r = r,
                eta = eta, nu = nu, kappa = kappa,
                topup = topup,
                seed = seeds[b]
            )
            costs[b] <- sim$total_cost
            used_pre[b] <- sim$used_pre
        }

        data.frame(
            patch_size = ps,
            n_seeds = n_seeds,
            mean_cost = mean(costs),
            sd_cost = sd(costs),
            mean_used_pre = mean(used_pre)
        )
    })

    do.call(rbind, res)
}
```

Simulation across patch size

```{r}
eta_score <- eta_val # often set equal to true eta

p_aug <- augment_risk_spillover(p_true, adj, eta = eta_score)
rank_out <- make_ranking(p_aug, rho_target = 0.7, seed = 1)
score_spill <- rank_out$score

df_ps <- estimate_cost_by_patchsize(
    p_true = p_true, adj = adj, score_cell = score_spill,
    patch_sizes = seq(1, 60, 2),
    cover_mult = 2.0,
    alpha = alpha_val, f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    topup = TRUE,
    n_mc = 2000, seed = 1
)

ggplot(df_ps, aes(x = patch_size, y = mean_cost)) +
    geom_line() +
    geom_point(size = 1.5) +
    theme_minimal() +
    labs(x = "Patch size (cells)", y = "Mean total cost")

```

# ODE Model Approach

This section explores how the proportional reduction parameter $r$ varies as a function of vaccination delay, campaign duration, and vaccine efficacy, using a standard SIR model.

We model the dynamics of Susceptible ($S$), Infectious ($I$), and Recovered ($R$) individuals. The vaccination campaign is implemented as a flow from $S$ to $R$ at a daily rate $\rho$ during the campaign window $[t_{\text{start}}, t_{\text{start}} + t_{\text{dur}}]$.

To achieve a target vaccine coverage proportion $C$ with vaccine efficacy $\nu$ over a campaign duration $D$, the daily rate $\rho$ (applied to the remaining eligible population) is determined by:
$$
\rho = -\frac{\ln(1 - \nu C)}{D}
$$

The proportional reduction $r$ is defined as:
$$
r = 1 - \frac{\text{Cumulative cases (vaccination)}}{\text{Cumulative cases (baseline)}}
$$

```{r}
# Example simulation

# Parameters
target_coverage <- 0.9
vacc_duration <- 14

params <- list(
    N = 100000,
    I0 = 10,
    R0 = 2.5,
    gamma = 0.2,
    ve = 0.8, # vaccine efficacy, nu
    coverage = target_coverage,
    vacc_duration = vacc_duration
)

# Baseline (no vaccination)
sim_novax <- run_sir_vaccination(
    N = params$N, I0 = params$I0, R0 = params$R0, gamma = params$gamma,
    coverage = 0, vacc_start = 0, vacc_duration = 0, ve = 0
)

# With vaccination (starting at day 21)
sim_vax <- run_sir_vaccination(
    N = params$N, I0 = params$I0, R0 = params$R0, gamma = params$gamma,
    coverage = params$coverage, vacc_start = 21, vacc_duration = params$vacc_duration, ve = params$ve
)

# Calculate r
cases_novax <- tail(sim_novax$CumCases, 1)
cases_vax <- tail(sim_vax$CumCases, 1)
r_calc <- 1 - (cases_vax / cases_novax)

print(paste0("Baseline cases: ", round(cases_novax)))
print(paste0("Vaccinated cases: ", round(cases_vax)))
print(paste0("Proportional reduction r: ", round(r_calc, 3)))
```

## Sensitivity analysis: delay and efficacy

We can systematically explore how $r$ changes with the delay in start time and vaccine efficacy.

```{r}
delays <- seq(10, 60, by = 5)
ves <- c(0.5, 0.7, 0.9)
R0s <- c(1.5, 2.5, 3.5)

results <- expand.grid(delay = delays, ve = ves, R0 = R0s)
results$r <- NA

for (i in seq_len(nrow(results))) {
    res <- calculate_r_ode(
        N = params$N, I0 = params$I0, R0 = results$R0[i],
        gamma = params$gamma,
        vacc_start = results$delay[i],
        ve = results$ve[i],
        coverage = params$coverage,
        vacc_duration = params$vacc_duration
    )
    results$r[i] <- res$r
}

ggplot(results, aes(x = delay, y = r, color = factor(ve))) +
    geom_line(linewidth = 1) +
    geom_point() +
    facet_wrap(~R0, labeller = label_both) +
    labs(
        title = "Impact of vaccination delay, efficacy, and R0 on r",
        x = "Vaccination start day",
        y = "Proportional reduction (r)",
        color = "Vaccine efficacy"
    ) +
    theme_light()
```

# Overall effectiveness approach

Alternatively, we can compute the expected number of cases by directly applying an "overall effectiveness" factor to the baseline cases. This approach simplifies the dynamics by assuming that the total impact of vaccination (direct + indirect effects) can be captured by a single effectiveness parameter $VE_{\text{overall}}$.

$$
VE_{\text{overall}} = 1 - (f(1-VE_{\text{direct}})(1-VE_{\text{indirect}}) + (1-f)(1-VE_{\text{indirect}})),
$$

where $VE_{\text{overall}}$ is a function of coverage ($f$), direct vaccine efficacy ($VE_{\text{direct}}$), and indirect vaccine effectiveness ($VE_{\text{indirect}}$). This formula accounts for the fact that vaccinated individuals are protected by both the vaccine and herd effects, while unvaccinated individuals benefit only from herd effects. See [this blog post](https://www.jonghoonk.com/blog/posts/vaccine_effectiveness/) for more details.

# Comparison of ODE and OVE approaches

In this section, we compare the reduction in cumulative cases estimated by the full ODE model against the "overall effectiveness" approach, where the latter is informed by the indirect vaccine effectiveness (IVE) derived from the ODE model.

We transform the time-dependent IVE into a single summary scalar (the final IVE) for the OVE approach because the final value is the only value that matters to consider the effectiveness is computed using the cumulative cases in our examples. 

$$
\text{IVE}(t) = 1 - \frac{\text{Risk}_{\text{unvax, vax}}(t)}{\text{Risk}_{\text{unvax, novax}}(t)}
$$

We check if:
$$
\text{Cases}_{\text{ODE}} = \text{Cases}_{\text{Baseline}} \times (1 - \text{OVE})
$$

```{r}
# Parameters
test_N <- 100000
test_I0 <- 1
test_R0 <- 2.0
test_gamma <- 0.2
test_ve <- 0.7
test_coverage <- 0.9
test_start <- 10
test_vacc_dur <- 10
test_sim_duration <- 700

# 1. ODE IVE Calculation
ive_res <- calculate_ive_ode(
    N = test_N, I0 = test_I0, R0 = test_R0, gamma = test_gamma,
    coverage = test_coverage, ve = test_ve, duration = test_sim_duration
)

# Extract final IVE
final_ive <- ive_res$ive
print(paste("Final IVE from ODE:", round(final_ive, 4)))

# 2. Compare case reductions
# ODE Results
# For exact comparison, let's re-run verify:
ode_check <- calculate_r_ode(
    N = test_N, I0 = test_I0, R0 = test_R0, gamma = test_gamma,
    coverage = test_coverage, vacc_start = test_start, vacc_duration = test_vacc_dur, ve = test_ve
)
ode_cases_vax <- tail(ode_check$sim_vax$CumCases, 1)
ode_cases_novax <- tail(ode_check$sim_novax$CumCases, 1)

# OVE Approach Calculation
cum_novax <- ode_check$sim_novax$CumCases
inc_novax <- c(cum_novax[1], diff(cum_novax))

# Use the refactored function
ove_res <- calculate_cases_overall_effectiveness(
    incidence_baseline = inc_novax,
    time = ode_check$sim_novax$time,
    coverage = test_coverage,
    ve_direct = test_ve,
    ve_indirect = final_ive,
    vacc_start = test_start + test_vacc_dur / 2
)

plot(inc_novax)
cum_vax <- ode_check$sim_vax$CumCases
inc_vax <- c(cum_vax[1], diff(cum_vax))
lines(inc_vax, col = 2)
lines(ove_res$incidence_post, col = 3)

ove_cases_vax <- tail(ove_res$cases_post, 1)

print(paste("ODE cases:", round(ode_cases_vax)))
print(paste("OVE cases:", round(ove_cases_vax)))

vals <- c(ode_cases_vax, ove_cases_vax)
names(vals) <- c("ODE Model", "OVE Approach")
barplot(vals, main = "Comparison of final Cases", col = c("steelblue", "orange"), ylab = "Cumulative Cases")
abline(h = ode_cases_novax, col = "red", lty = 2)
text(x = 1.5, y = ode_cases_novax, labels = "Baseline (No Vax)", pos = 3, col = "red")
```

```{r, fig.width=10, fig.height=8}
# Parameters for comparison
R0_vals <- c(1.5, 2.5, 4.0)
coverage_vals <- c(0.5, 0.7, 0.9)
start_vals <- seq(0, 40, by = 10)

# Fixed parameters
fix_N <- 100000
fix_I0 <- 10
fix_gamma <- 0.2
fix_ve <- 0.7
fix_dur <- 365 * 2
fix_vacc_dur <- 10
fix_ts <- 1 # a day

results_list <- list()
counter <- 1

for (r0 in R0_vals) {
    for (cov in coverage_vals) {
        # Calculate IVE once per R0/Coverage (assuming Pre-emptive IVE baseline)
        ive_res <- calculate_ive_ode(
            N = fix_N, I0 = fix_I0, R0 = r0, gamma = fix_gamma,
            coverage = cov, ve = fix_ve, duration = fix_dur, time_step = fix_ts
        )
        final_ive <- ive_res$ive

        for (st in start_vals) {
            # 1. ODE Simulation
            ode_res <- calculate_r_ode(
                N = fix_N, I0 = fix_I0, R0 = r0, gamma = fix_gamma,
                coverage = cov, vacc_start = st, vacc_duration = fix_vacc_dur,
                ve = fix_ve, duration = fix_dur, time_step = fix_ts
            )

            cases_ode <- tail(ode_res$sim_vax$CumCases, 1)
            cases_novax <- tail(ode_res$sim_novax$CumCases, 1)
            pct_red_ode <- 1 - (cases_ode / cases_novax)

            # 2. OVE Approach
            # Get baseline incidence
            inc_novax <- c(ode_res$sim_novax$CumCases[1], diff(ode_res$sim_novax$CumCases))

            ove_res <- calculate_cases_overall_effectiveness(
                incidence_baseline = inc_novax,
                time = ode_res$sim_novax$time,
                coverage = cov,
                ve_direct = fix_ve,
                ve_indirect = final_ive,
                vacc_start = st + fix_vacc_dur / 2
            )

            cases_ove <- tail(ove_res$cases_post, 1)
            pct_red_ove <- 1 - (cases_ove / cases_novax)

            # Differences
            abs_diff <- pct_red_ode - pct_red_ove
            rel_diff <- if (pct_red_ode != 0) (pct_red_ode - pct_red_ove) / pct_red_ode else NA

            results_list[[counter]] <- data.frame(
                R0 = r0,
                Coverage = cov,
                Start = st,
                Cases_ODE = cases_ode,
                Cases_OVE = cases_ove,
                PctRed_ODE = pct_red_ode,
                PctRed_OVE = pct_red_ove,
                AbsDiff = abs_diff,
                RelDiff = rel_diff,
                IVE = final_ive
            )
            counter <- counter + 1
        }
    }
}

df_res <- do.call(rbind, results_list)

# Reshape for Plotting
df_long <- pivot_longer(df_res,
    cols = c("PctRed_ODE", "PctRed_OVE"),
    names_to = "Method",
    values_to = "PctReduction"
)
df_long$Method <- ifelse(df_long$Method == "PctRed_ODE", "ODE", "OVE")


# Plot: % Reduction Comparison
p1 <- ggplot(df_long, aes(x = Start, y = PctReduction, color = Method)) +
    geom_line(linewidth = 1) +
    geom_point() +
    facet_grid(R0 ~ Coverage, labeller = label_both) +
    labs(
        title = "Comparison of Case Reduction: ODE vs OVE Approach",
        subtitle = "Across R0 (rows) and Coverage (columns)",
        y = "% Reduction in Cumulative Cases",
        x = "Vaccination Start Time (days)"
    ) +
    theme_light() +
    ylim(0, 1)

print(p1)

# Display a subset of results
knitr::kable(head(df_res, 10), digits = 3, caption = "Comparison Results (First 10)")
knitr::kable(tail(df_res, 10), digits = 3, caption = "Comparison Results (Last 10)")
```



