---
title: "Model extension"
author: "Jong-Hoon Kim"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
library(MASS)
library(Matrix)
library(dplyr)
library(ggplot2)
source("R/load_all.R")
```

# Spatially correlated outbreak risks and spillover

This section presents a description of the outbreak and vaccination model. The exposition is organized to move from baseline risk, to spillover, to vaccination, and finally to expected costs. The framework is static (one-year) and designed to balance realism with analytical transparency.

---

## Notation and setup

We consider a population divided into $n$ spatial units (grid cells), indexed by $i \in \{1,\dots,n\}$.

- Neighborhood of cell $i$: $\mathcal{N}(i)$ (e.g., rook or queen adjacency)
- Adjacency indicator: $A_{ij} = \mathbf{1}\{j \in \mathcal{N}(i)\}$
- Primary outbreak indicator: $Y_i^{(0)} \in \{0,1\}$
- Secondary (spillover) outbreak indicator: $Y_i^{(1)} \in \{0,1\}$
- Final outbreak indicator: $Y_i \in \{0,1\}$
- Baseline outbreak probability: $p_i \in (0,1)$
- Spillover strength parameter: $\eta \in [0,1]$

We distinguish between **primary outbreaks**, driven by baseline vulnerability, and **secondary outbreaks**, arising through local spillover from neighboring primary outbreaks.

---

## Spatially correlated baseline outbreak risk

Each cell $i$ has a baseline probability $p_i$ of experiencing a primary outbreak, representing environmental, infrastructural, and socio-demographic vulnerability prior to local transmission.

Baseline risks are generated from a latent spatial field,
$$
Z \sim \mathcal{N}(0, \Sigma(\phi)), \qquad
p_i = \mathrm{logit}^{-1}(\mu + Z_i),
$$
where $\Sigma(\phi)$ encodes spatial dependence and $\phi$ controls the strength and range of correlation. The intercept $\mu$ sets the overall mean outbreak probability.

Conditional on $p=(p_1,\dots,p_n)$, primary outbreaks occur independently:
$$
Y_i^{(0)} \mid p_i \sim \mathrm{Bernoulli}(p_i), \qquad i=1,\dots,n.
$$

---

## Spillover-driven secondary outbreaks

Let
$$
K_i = \sum_{j \in \mathcal{N}(i)} Y_j^{(0)}
$$
denote the number of neighboring primary outbreaks.

Spillover is modeled using a monotone dose–response function,
$$
h(K_i) = 1 - (1-\eta)^{K_i},
$$
which satisfies $h(0)=0$ and increases smoothly with $K_i$.

Conditional on $K_i$,
$$
Y_i^{(1)} \mid K_i \sim \mathrm{Bernoulli}\!\left(h(K_i)\right).
$$

The final outbreak indicator is
$$
Y_i = 1 - (1 - Y_i^{(0)})(1 - Y_i^{(1)}),
$$
so that
$$
\Pr(Y_i = 1 \mid p, K_i)
= p_i + (1-p_i)\,h(K_i).
$$

This reduced-form representation captures spatial amplification of outbreak risk without explicitly modeling transmission dynamics.

Secondary outbreaks do not generate further spillover; this prevents epidemic cascades and keeps the model analytically tractable.
---

## Vaccination effects

Let $V_i \in \{0,1\}$ indicate whether cell $i$ is vaccinated pre-emptively.

Vaccination modifies both baseline risk and spillover susceptibility:

- **Baseline risk reduction**
$$
p_i(V_i) = (1-\nu V_i)\,p_i,
$$
where $\nu \in [0,1]$ is effectiveness against primary outbreaks.

- **Spillover susceptibility reduction**
$$
\eta(V_i) = (1-\kappa V_i)\,\eta,
$$
where $\kappa \in [0,1]$ captures protection against secondary spread.

These modified quantities are substituted directly into the outbreak equations.

---

## Expected outbreak probability (cell level)

Conditioning on baseline risks $p$, the expected outbreak probability in cell $i$ is
$$
\mathbb{E}[Y_i \mid p]
=
p_i + (1-p_i)\left(1-\prod_{j\in\mathcal{N}(i)}(1-\eta p_j)\right).
$$

Spillover therefore depends on the joint configuration of neighboring baseline risks, not merely their average.

Vaccination does not reduce infectiousness of neighbors (i.e., no outward spillover reduction), only susceptibility.
---

## Expected outbreak count

Let  
$$
N_{\mathrm{out}} = \sum_{i=1}^n Y_i
$$
denote the total number of outbreak cells.

Conditional on $p$,
$$
\mathbb{E}[N_{\mathrm{out}} \mid p]
=
\sum_{i=1}^n
\left[
p_i + (1-p_i)\left(1-\prod_{j\in\mathcal{N}(i)}(1-\eta p_j)\right)
\right].
$$

When $p$ itself is random and spatially correlated,
$$
\mathbb{E}[N_{\mathrm{out}}]
=
\mathbb{E}_p\!\left[\mathbb{E}[N_{\mathrm{out}} \mid p]\right].
$$
This quantity does not admit a closed form and is evaluated via Monte Carlo simulation.

---

## Expected total cost under a mixed vaccination strategy

### Decisions and constraints

- Pre-emptive vaccination: $V_i \in \{0,1\}$ (chosen before outbreaks)
- Reactive vaccination: $R_i \in \{0,1\}$ (chosen after observing outbreaks), with $R_i \le Y_i$
- Vaccine cost per cell: $C_V$
- Unmitigated outbreak cost per cell: $C_I$
- Cost ratio: $R = C_I/C_V$
- Reactive effectiveness: $r \in [0,1]$

Total vaccination capacity allows vaccination of a fraction $f$ of cells. A fraction $\alpha$ is allocated pre-emptively, leaving reactive capacity
$$
B_{\mathrm{re}} = (1-\alpha) f n.
$$

Reactive vaccination is subject to the followig rule,
$$
\sum_{i=1}^n R_i = \min(N_{\mathrm{out}}, B_{\mathrm{re}}).
$$

---

### Expected cost

Vaccination cost:
$$
C_{vacc}
=
C_V\sum_{i=1}^n V_i
+
C_V\,\mathbb{E}\!\left[\sum_{i=1}^n R_i\right].
$$

Outbreak cost:
$$
\mathbb{E}[C_{out}]
=
C_I\left(
\mathbb{E}[N_{out}]
-
r\,\mathbb{E}\!\left[\sum_{i=1}^n R_i\right]
\right).
$$

Total expected cost:
$$
\mathbb{E}[C_{\mathrm{total}}]
=
C_V\sum_{i=1}^n V_i
+
C_I\,\mathbb{E}[N_{\mathrm{out}}]
+
(C_V-rC_I)\,
\mathbb{E}\!\left[\min(N_{\mathrm{out}}, B_{\mathrm{re}})\right].
$$

---

## Role of spillover

Spillover influences expected costs only through the distribution of $N_{\mathrm{out}}$. There is no direct spillover term in the cost function; all effects are mediated by changes in outbreak occurrence.

---

## Simulation workflow

Expected costs are evaluated by Monte Carlo simulation:

1. Draw a spatially correlated risk field $p$
2. Sample primary outbreaks $Y^{(0)}$
3. Compute $K_i$ and sample secondary outbreaks $Y^{(1)}$
4. Construct final outbreaks $Y$ and $N_{\mathrm{out}}$
5. Apply reactive allocation
6. Compute realized costs and average across replicates

---

### Mixed strategy simulation

```{r}
simulate_patch_spillover <- function(p_true, score_cell,
                                     adj, patches, patch_df,
                                     alpha, f, R, r,
                                     eta = 0.2, nu = 0, kappa = 0,
                                     seed = NULL) {
    if (!is.null(seed)) set.seed(seed)

    stopifnot(
        alpha >= 0, alpha <= 1, f > 0, f <= 1, R >= 0, r >= 0, r <= 1,
        is.numeric(p_true), all(p_true > 0), all(p_true < 1),
        is.numeric(score_cell), length(score_cell) == length(p_true)
    )

    patches <- patches[!vapply(patches, is.null, logical(1))]
    Kpatch <- length(patches)
    stopifnot(nrow(patch_df) == Kpatch)

    n <- length(p_true)

    # Budgets in number of CELLS
    B_pre <- alpha * f * n
    B_react <- (1 - alpha) * f * n
    # -------------------------------------------------
    # 1. Pre-emptive vaccination (PATCH level, score-based)
    # -------------------------------------------------

    pre <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
    pre_vax_patch <- as.logical(pre$pre_vax)
    used_pre <- as.numeric(pre$used)

    V_pre_cell <- rep(FALSE, n)
    if (any(pre_vax_patch)) {
        for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
    }

    # -------------------------------------------------
    # 2. Outbreak realization (CELL level, true risk)
    # -------------------------------------------------
    outb <- simulate_outbreak_spillover(
        p = p_true,
        adj = adj,
        vax = V_pre_cell,
        eta = eta,
        nu = nu,
        kappa = kappa
    )

    Y_cell <- as.logical(outb$Y)
    Y0_cell <- outb$Y0
    Y1_cell <- outb$Y1

    # -------------------------------------------------
    # 3. Reactive vaccination (CELL level, observation-only)
    # -------------------------------------------------

    outbreak_cells <- which(Y_cell & !V_pre_cell)

    used_react <- min(length(outbreak_cells), floor(B_react))
    react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

    V_react_cell <- rep(FALSE, n)
    if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

    V_any_cell <- V_pre_cell | V_react_cell

    # -------------------------------------------------
    # 4. Costs (CELL level)
    # -------------------------------------------------

    vax_cost_total <- used_pre + used_react

    outbreak_cost <- R * sum(
        as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1)
    )

    total_cost <- vax_cost_total + outbreak_cost

    # -------------------------------------------------
    # 5. Derived PATCH summaries (reporting only
    # -------------------------------------------------

    outbreak_patch <- vapply(
        seq_len(Kpatch),
        function(k) any(Y_cell[patches[[k]]]),
        logical(1)
    )

    react_vax_patch <- vapply(
        seq_len(Kpatch),
        function(k) any(V_react_cell[patches[[k]]]),
        logical(1)
    )

    list(
        total_cost = total_cost,
        vax_cost = vax_cost_total,
        outbreak_cost = outbreak_cost,
        # Cell-level (primary outputs)
        V_pre_cell = V_pre_cell,
        V_react_cell = V_react_cell,
        V_any_cell = V_any_cell,
        Y_cell = Y_cell,
        Y0_cell = Y0_cell,
        Y1_cell = Y1_cell,

        # Patch-level (derived)
        pre_vax_patch = pre_vax_patch,
        react_vax_patch = react_vax_patch,
        outbreak_patch = outbreak_patch,

        # Bookkeeping
        used_pre = used_pre,
        used_react = used_react,
        B_pre = B_pre,
        B_react = B_react
    )
}

```

---

### Monte Carlo evaluation and optimization
```{r}
estimate_cost_alpha_patch_spillover <-
    function(p_true, score_cell, adj, patches, patch_df,
             alpha, f, R, r, eta = 0.2, nu = 0, kappa = 0,
             n_mc = 2000, seed = NULL) {
        if (!is.null(seed)) set.seed(seed)

        n <- length(p_true)
        B_pre <- alpha * f * n
        B_react <- (1 - alpha) * f * n

        # Pre-emptive allocation (deterministic given inputs)
        pre <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
        pre_vax_patch <- as.logical(pre$pre_vax)
        used_pre <- as.numeric(pre$used)

        V_pre_cell <- rep(FALSE, n)
        if (any(pre_vax_patch)) {
            # Fix: Ensure patches are valid indices
            for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
        }

        costs <- replicate(n_mc, {
            # Outbreak
            outb <- simulate_outbreak_spillover(
                p = p_true,
                adj = adj,
                vax = V_pre_cell,
                eta = eta,
                nu = nu,
                kappa = kappa
            )
            Y_cell <- as.logical(outb$Y)

            # Reactive
            outbreak_cells <- which(Y_cell & !V_pre_cell)
            used_react <- min(length(outbreak_cells), floor(B_react))

            V_react_cell <- rep(FALSE, n)
            if (used_react > 0) {
                react_cells <- outbreak_cells[seq_len(used_react)]
                V_react_cell[react_cells] <- TRUE
            }

            # Cost
            vax_cost_total <- used_pre + used_react
            outbreak_cost <- R * sum(as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1))

            vax_cost_total + outbreak_cost
        })
        c(mean = mean(costs), sd = sd(costs))
    }
```

```{r}
alpha_star_patch_grid_spillover <-
    function(p_true, score_cell, adj, patches, patch_df,
             f, R, r, eta = 0.2, nu = 0, kappa = 0,
             alpha_grid = seq(0, 1, by = 0.05), n_mc = 2000, seed = NULL) {
        res <- data.frame(alpha = alpha_grid, mean_cost = NA_real_)

        for (i in seq_along(alpha_grid)) {
            res$mean_cost[i] <- estimate_cost_alpha_patch_spillover(
                p_true = p_true, score_cell = score_cell,
                adj = adj, patches = patches, patch_df = patch_df,
                alpha = alpha_grid[i], f = f, R = R, r = r,
                eta = eta, nu = nu, kappa = kappa,
                n_mc = n_mc, seed = seed
            )["mean"]
        }

        list(alpha_star = res$alpha[which.min(res$mean_cost)], grid = res)
    }
```

---

# Example run

```{r}
nx <- 25
ny <- 20
rho0_val <- 0.6
ell_val <- 4
theta_val <- 3

rho_target_val <- 0.7
n_seeds_val <- 10
patch_size_val <- 40

alpha_val <- 0.5
f_val <- 0.3
R_val <- 5
r_val <- 0.6
eta_val <- 0.8
nu_val <- 0.9
kappa_val <- 0.8

n_mc <- 1000

coords <- as.matrix(expand.grid(x = 1:nx, y = 1:ny))

sim <- spatial_beta_risk(coords,
    theta = theta_val,
    rho0 = rho0_val, ell = ell_val
)
p_true <- sim$p

rank_out <- make_ranking(p_true, rho_target = rho_target_val)
score_cell <- rank_out$score

adj <- make_adj(coords, type = "distance", d0 = 1.01)

patch_out <- make_patches(score_cell,
    adj,
    n_seeds = n_seeds_val,
    patch_size = patch_size_val
)
patches <- patch_out$patches
patches <- patches[!vapply(patches, is.null, logical(1))]

patch_df <- summarize_patches(list(score = score_cell, patches = patches))

opt <- alpha_star_patch_grid_spillover(
    p_true = p_true,
    score_cell = score_cell,
    adj = adj,
    patches = patches,
    patch_df = patch_df,
    f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    alpha_grid = seq(0, 1, by = 0.02),
    n_mc = 2000,
    seed = 1
)
opt$alpha_star

ggplot(opt$grid, aes(alpha, mean_cost)) +
    geom_line() +
    theme_light()
```


# Figures

## Figure 1. Spatially correlated risks $p_i$

```{r}
df_risk <- data.frame(
    x = coords[, 1],
    y = coords[, 2],
    p = p_true
)

ggplot(df_risk, aes(x = x, y = y, fill = p)) +
    geom_tile() +
    coord_equal() +
    labs(
        title = expression("Spatially correlated risks " * italic(p)[i]),
        x = NULL, y = NULL, fill = "p_i"
    ) +
    theme_minimal(base_size = 12)
```

## Figure 2. Imperfect risk score vs true risk

```{r}
df_score <- data.frame(p = p_true, score = score_cell)
ggplot(df_score, aes(x = p, y = score)) +
    geom_point(alpha = 0.4) +
    labs(
        title = paste0(
            "Imperfect score vs true risk (Spearman rho = ",
            round(rank_out$rho_achieved, 2), ")"
        ),
        x = expression(italic(p)[i]), y = "score_i"
    ) +
    theme_light()
```

## Figure 3. Patch map

```{r, fig.width=7, fig.height=4.5}
patch_id_vec <- patch_out$patch_id
df_patchmap <- data.frame(
    x = coords[, 1],
    y = coords[, 2],
    patch = factor(patch_id_vec)
)

ggplot(df_patchmap, aes(x = x, y = y, fill = patch)) +
    geom_tile() +
    coord_equal() +
    guides(fill = "none") +
    labs(
        title = "Patches (contiguous groups grown from high-score seeds)",
        x = NULL, y = NULL
    ) +
    theme_minimal(base_size = 12)
```

## Figure 4.Simulated pre-emptive vs reactive vs outbreaks

```{r}
# Budgets (calculated here for this specific realization)
n <- length(p_true)
B_pre <- floor(alpha_val * f_val * n)
B_react <- floor((1 - alpha_val) * f_val * n)
# 1. Pre-emptive allocation
pre_alloc <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
pre_vax_patch <- as.logical(pre_alloc$pre_vax)
V_pre_cell <- rep(FALSE, n)
if (any(pre_vax_patch)) {
    for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
}
# 2. Outbreak realization
outb <- simulate_outbreak_spillover(
    p = p_true,
    adj = adj,
    vax = V_pre_cell,
    eta = eta_val,
    nu = nu_val,
    kappa = kappa_val
)
Y_cell <- as.logical(outb$Y)
# 3. Reactive vaccination
outbreak_cells <- which(Y_cell & !V_pre_cell)
used_react <- min(length(outbreak_cells), B_react)
V_react_cell <- rep(FALSE, n)
if (used_react > 0) {
    react_cells <- outbreak_cells[seq_len(used_react)]
    V_react_cell[react_cells] <- TRUE
}
df_state <-
    data.frame(
        x = coords[, 1],
        y = coords[, 2],
        pre = V_pre_cell,
        react = V_react_cell,
        out = Y_cell
    ) %>%
    mutate(state = dplyr::case_when(
        out & react ~ "Outbreak + reactive",
        out & !react ~ "Outbreak (unmitigated)",
        !out & pre ~ "Pre-emptive vaccinated",
        !out & react ~ "Reactive vaccinated (no outbreak)",
        TRUE ~ "None"
    ))
ggplot(df_state, aes(x = x, y = y, fill = state)) +
    geom_tile() +
    coord_equal() +
    labs(
        title = paste0("Realization (alpha = ", alpha_val, ")"),
        x = NULL, y = NULL, fill = NULL
    ) +
    theme_light(base_size = 12)
```


## Figure 5. Cost curve across $\alpha$ and estimated $\alpha^*$

```{r, fig.width=7, fig.height=4.5}
opt <- alpha_star_patch_grid_spillover(
    p_true = p_true,
    score_cell = score_cell,
    adj = adj,
    patches = patches,
    patch_df = patch_df,
    f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    alpha_grid = seq(0, 1, by = 0.02),
    n_mc = 2000,
    seed = 1
)

ggplot(opt$grid, aes(x = alpha, y = mean_cost)) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    geom_vline(xintercept = opt$alpha_star, linetype = "dashed") +
    labs(
        title = paste0("Mean cost vs alpha (alpha* = ", opt$alpha_star, ")"),
        x = expression(alpha),
        y = "Mean cost (units of C_V)"
    ) +
    theme_light(base_size = 12)
```

---
### Experiement

Compare two alternative vaccination strategies. In Strategy A, pre-emptive vaccination occurs at the patch level after accounting for spill-over risk in addition to cell-level risk (environmental factors). In Strategy B, pre-emptive vaccination occurs at the cell level that only accounts for the cell-level risk (environmental factors). Reactive vaccination occurs at the cell level in both strategies.

```{r}


```

2) Strategy A: Cell-level pre-emptive simulator (thin wrapper)

```{r}
simulate_cell_spillover <- function(p_true, score_cell,
                                    adj,
                                    alpha, f, R, r,
                                    eta = 0.2, nu = 0, kappa = 0,
                                    seed = NULL) {
    if (!is.null(seed)) set.seed(seed)

    stopifnot(length(p_true) == length(score_cell))
    n <- length(p_true)

    # Budgets in CELLS
    B_pre <- alpha * f * n
    B_react <- (1 - alpha) * f * n

    # -------------------------------------------------
    # 1) Pre-emptive vaccination (CELL level, score-based)
    # -------------------------------------------------
    ord <- order(score_cell, decreasing = TRUE)
    used_pre <- min(floor(B_pre), n)
    pre_cells <- if (used_pre > 0) ord[seq_len(used_pre)] else integer(0)

    V_pre_cell <- rep(FALSE, n)
    if (length(pre_cells) > 0) V_pre_cell[pre_cells] <- TRUE

    # -------------------------------------------------
    # 2) Outbreak realization (CELL level, true risk)
    # -------------------------------------------------
    outb <- simulate_outbreak_spillover(
        p = p_true,
        adj = adj,
        vax = V_pre_cell,
        eta = eta,
        nu = nu,
        kappa = kappa
    )
    Y_cell <- as.logical(outb$Y)

    # -------------------------------------------------
    # 3) Reactive vaccination (CELL level, observation-only)
    # -------------------------------------------------
    outbreak_cells <- which(Y_cell & !V_pre_cell)

    used_react <- min(length(outbreak_cells), floor(B_react))
    react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

    V_react_cell <- rep(FALSE, n)
    if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

    # -------------------------------------------------
    # 4) Costs (CELL level, units of C_V)
    # -------------------------------------------------
    vax_cost_total <- used_pre + used_react

    outbreak_cost <- R * sum(
        as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1)
    )

    total_cost <- vax_cost_total + outbreak_cost

    list(
        total_cost = total_cost,
        vax_cost = vax_cost_total,
        outbreak_cost = outbreak_cost,
        V_pre_cell = V_pre_cell,
        V_react_cell = V_react_cell,
        Y_cell = Y_cell,
        used_pre = used_pre,
        used_react = used_react,
        B_pre = B_pre,
        B_react = B_react
    )
}

```

3) Strategy B: Patch-level pre-emptive, spillover-aware
We can recycle functions that we have 

- `make_patches(score, adj, ...)`
- `summarize_patches(p_true, score_cell, patches)` (uses mean score per patch)
- `allocate_preemptive_targeted(patch_df, B_pre)`
- `simulate_patch_spillover(...)` (does patch-level pre + cell-level reactive + cost)

We will feed it a spillover-aware score (derived from p_aug), while keeping outbreak generation driven by p_true.

4) Build the two strategy inputs (scores + patches)
This is the key “setup” function that you run once per scenario.
```{r}
build_strategy_objects <- function(p_true, adj,
                                   rho_cell = 0.7,
                                   rho_patch = 0.7,
                                   eta_score = 0.8,
                                   n_seeds = 10,
                                   patch_size = 40,
                                   seed_cell = 1,
                                   seed_patch = 2) {
    # ---- Strategy A score: cell-risk only (imperfect ranking of p_true)
    rank_cell <- make_ranking(p_true,
        rho_target = rho_cell,
        seed = seed_cell
    )
    score_cell <- rank_cell$score

    # ---- Strategy B score: spillover-aware (imperfect ranking of augmented risk)
    p_aug <- augment_risk_spillover(p_true, adj, eta = eta_score)
    rank_patch <- make_ranking(p_aug, rho_target = rho_patch, seed = seed_patch)
    score_spill <- rank_patch$score

    # ---- Patches built from spillover-aware score (consistent with strategy B)
    patch_out <- make_patches(score_spill, adj,
        n_seeds = n_seeds,
        patch_size = patch_size
    )
    patches <- patch_out$patches
    patches <- patches[!vapply(patches, is.null, logical(1))]
    patch_df <- summarize_patches(list(score = score_spill, patches = patches))

    list(
        # Strategy A
        score_cell = score_cell,
        rank_cell = rank_cell,

        # Strategy B
        p_aug = p_aug,
        score_spill = score_spill,
        rank_patch = rank_patch,
        patches = patches,
        patch_df = patch_df,
        patch_id = patch_out$patch_id
    )
}

```


```{r}
compare_cell_vs_patch <- function(p_true,
                                  score_cell,
                                  adj,
                                  patches, patch_df,
                                  score_spill,
                                  alpha, f, R, r,
                                  eta = 0.8, nu = 0.9, kappa = 0.8,
                                  n_mc = 1000, seed = 1) {
    set.seed(seed)
    seeds <- sample.int(1e9, n_mc)

    cost_cell <- numeric(n_mc)
    cost_patch <- numeric(n_mc)

    for (b in seq_len(n_mc)) {
        s <- seeds[b]

        A <- simulate_cell_spillover(
            p_true = p_true,
            score_cell = score_cell,
            adj = adj,
            alpha = alpha, f = f, R = R, r = r,
            eta = eta, nu = nu, kappa = kappa,
            seed = s
        )

        B <- simulate_patch_spillover(
            p_true = p_true,
            score_cell = score_spill, # used ONLY for patch targeting
            adj = adj,
            patches = patches,
            patch_df = patch_df,
            alpha = alpha, f = f, R = R, r = r,
            eta = eta, nu = nu, kappa = kappa,
            seed = s
        )

        cost_cell[b] <- A$total_cost
        cost_patch[b] <- B$total_cost
    }

    df <- data.frame(
        cost_cell = cost_cell,
        cost_patch = cost_patch,
        diff = cost_patch - cost_cell
    )

    list(
        summary = c(
            mean_cell  = mean(df$cost_cell),
            mean_patch = mean(df$cost_patch),
            mean_diff  = mean(df$diff),
            sd_diff    = sd(df$diff)
        ),
        draws = df
    )
}
```

Simulation parameters

```{r}
# --- build risks + adjacency (as you already do) ---
nx <- 25
ny <- 20
rho0_val <- 0.8
ell_val <- 20
theta_val <- 5
# rho_target_val <- 0.7
# n_seeds_val <- 10
# patch_size_val = 40

alpha_val <- 0.8
f_val <- 0.4
R_val <- 10
r_val <- 0.3
eta_val <- 0.9
nu_val <- 0.9
kappa_val <- 0.9

n_seeds_val <- 10
patch_size_val <- 2
```

Simulation
```{r}
coords <- as.matrix(expand.grid(x = 1:nx, y = 1:ny))

sim <- spatial_beta_risk(coords,
    theta = theta_val,
    rho0 = rho0_val, ell = ell_val
)
p_true <- sim$p
adj <- make_adj(coords, type = "rook") # or distance/queen

# --- strategy objects ---
obj <- build_strategy_objects(
    p_true = p_true,
    adj = adj,
    rho_cell = 0.7,
    rho_patch = 0.7,
    eta_score = 0.8,
    n_seeds = n_seeds_val,
    patch_size = patch_size_val,
    seed_cell = 1,
    seed_patch = 2
)

# --- compare at a chosen alpha ---
res <- compare_cell_vs_patch(
    p_true = p_true,
    score_cell = obj$score_cell,
    adj = adj,
    patches = obj$patches,
    patch_df = obj$patch_df,
    score_spill = obj$score_spill,
    alpha = alpha_val, f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    n_mc = 2000, seed = 1
)

res$summary

```

`allocate_preemptive_targeted()` is a greedy knapsack by patch size, but it can leave unused budget when patch sizes are chunky. That would confound a patch-size experiment (bigger patches look worse partly because you “wasted” doses).

Select best patches until you cannot add another patch without exceeding 
the budget for the pre-emptive vaccination. If leftover budget remains, top up with best remaining cells (by the same spillover-aware score) outside vaccinated cells.

This makes dose usage comparable across patch sizes.
```{r}
allocate_preemptive_patches_with_topup <- function(patch_df, patches, score_cell, B_pre, n) {
    ord <- order(patch_df$S_hat, decreasing = TRUE)

    V_pre <- rep(FALSE, n)
    used <- 0L

    # 1) take whole patches greedily
    for (k in ord) {
        m <- patch_df$m[k]
        if (used + m <= B_pre) {
            V_pre[patches[[k]]] <- TRUE
            used <- used + m
        }
    }

    # 2) top-up with best remaining cells (optional)
    leftover <- B_pre - used
    if (leftover > 0) {
        cand <- which(!V_pre)
        if (length(cand) > 0) {
            ord_cell <- cand[order(score_cell[cand], decreasing = TRUE)]
            take <- ord_cell[seq_len(min(leftover, length(ord_cell)))]
            V_pre[take] <- TRUE
            used <- used + length(take)
        }
    }

    list(V_pre_cell = V_pre, used = used)
}

```

```{r}
simulate_preemptive_by_patchsize <- function(p_true, adj,
                                             score_cell,
                                             patch_size,
                                             n_seeds,
                                             alpha, f, R, r,
                                             eta = 0.2, nu = 0, kappa = 0,
                                             topup = TRUE,
                                             seed = NULL) {
    if (!is.null(seed)) set.seed(seed)
    n <- length(p_true)

    # budgets
    B_pre <- floor(alpha * f * n)
    B_react <- floor((1 - alpha) * f * n)

    # ---- patch_size = 1 means "cell-level pre-emptive"
    if (patch_size == 1) {
        ord <- order(score_cell, decreasing = TRUE)
        pre_cells <- ord[seq_len(min(B_pre, n))]
        V_pre_cell <- rep(FALSE, n)
        V_pre_cell[pre_cells] <- TRUE
        used_pre <- sum(V_pre_cell)

        patches <- NULL
        patch_df <- NULL
    } else {
        # build patches using the SAME score_cell (spillover-aware score if you choose)
        patch_out <- make_patches(score_cell, adj,
            n_seeds = n_seeds,
            patch_size = patch_size
        )
        patches <- patch_out$patches
        patches <- patches[!vapply(patches, is.null, logical(1))]

        patch_df <- summarize_patches(list(score = score_cell, patches = patches))

        if (topup) {
            alloc <- allocate_preemptive_patches_with_topup(
                patch_df = patch_df, patches = patches,
                score_cell = score_cell, B_pre = B_pre, n = n
            )
            V_pre_cell <- alloc$V_pre_cell
            used_pre <- alloc$used
        } else {
            pre <- allocate_preemptive_patches(patch_df, B_pre = B_pre)
            used_pre <- as.integer(pre$used)
            pre_vax_patch <- as.logical(pre$pre_vax)
            V_pre_cell <- rep(FALSE, n)
            if (any(pre_vax_patch)) {
                for (k in which(pre_vax_patch)) V_pre_cell[patches[[k]]] <- TRUE
            }
            used_pre <- sum(V_pre_cell)
        }
    }

    # ---- outbreaks (true risk + spillover; identical)
    outb <- simulate_outbreak_spillover(
        p = p_true,
        adj = adj,
        vax = V_pre_cell,
        eta = eta,
        nu = nu,
        kappa = kappa
    )
    Y_cell <- as.logical(outb$Y)

    # ---- reactive (cell-level, observation-only)
    outbreak_cells <- which(Y_cell & !V_pre_cell)
    used_react <- min(length(outbreak_cells), B_react)
    react_cells <- if (used_react > 0) outbreak_cells[seq_len(used_react)] else integer(0)

    V_react_cell <- rep(FALSE, n)
    if (length(react_cells) > 0) V_react_cell[react_cells] <- TRUE

    # ---- costs
    vax_cost_total <- used_pre + used_react
    outbreak_cost <- R * sum(as.integer(Y_cell) * ifelse(V_react_cell, (1 - r), 1))
    total_cost <- vax_cost_total + outbreak_cost

    list(
        total_cost = total_cost,
        vax_cost = vax_cost_total,
        outbreak_cost = outbreak_cost,
        used_pre = used_pre,
        used_react = used_react,
        B_pre = B_pre,
        B_react = B_react,
        patch_size = patch_size,
        n_seeds = n_seeds
    )
}

```

```{r}
# spillover-aware risk proxy used ONLY for pre-emptive targeting
p_aug <- augment_risk_spillover(p_true, adj, eta = eta_val)

rank_out <- make_ranking(p_aug, rho_target = 0.8, seed = 1)
score_spill <- rank_out$score

```

```{r}
estimate_cost_by_patchsize <- function(p_true, adj, score_cell,
                                       patch_sizes = c(1, 2, 3, 5, 10, 20, 40),
                                       cover_mult = 2.0, # controls n_seeds as patch_size changes
                                       alpha, f, R, r,
                                       eta = 0.2, nu = 0, kappa = 0,
                                       topup = TRUE,
                                       n_mc = 1000, seed = 1) {
    n <- length(p_true)

    # choose n_seeds so candidate patch pool stays roughly comparable
    # target pool ~ cover_mult * B_pre_max where B_pre_max = f*n (alpha=1)
    B_pre_max <- floor(f * n)
    L_target <- min(cover_mult * B_pre_max, n)

    set.seed(seed)
    seeds <- sample.int(1e9, n_mc)

    res <- lapply(patch_sizes, function(ps) {
        n_seeds <- if (ps == 1) NA_integer_ else ceiling(L_target / ps)

        costs <- numeric(n_mc)
        used_pre <- numeric(n_mc)

        for (b in seq_len(n_mc)) {
            sim <- simulate_preemptive_by_patchsize(
                p_true = p_true, adj = adj,
                score_cell = score_cell,
                patch_size = ps,
                n_seeds = if (is.na(n_seeds)) 1 else n_seeds,
                alpha = alpha, f = f, R = R, r = r,
                eta = eta, nu = nu, kappa = kappa,
                topup = topup,
                seed = seeds[b]
            )
            costs[b] <- sim$total_cost
            used_pre[b] <- sim$used_pre
        }

        data.frame(
            patch_size = ps,
            n_seeds = n_seeds,
            mean_cost = mean(costs),
            sd_cost = sd(costs),
            mean_used_pre = mean(used_pre)
        )
    })

    do.call(rbind, res)
}

```

Simulation across patch size
```{r}
eta_score <- eta_val # often set equal to true eta

p_aug <- augment_risk_spillover(p_true, adj, eta = eta_score)
rank_out <- make_ranking(p_aug, rho_target = 0.7, seed = 1)
score_spill <- rank_out$score

df_ps <- estimate_cost_by_patchsize(
    p_true = p_true, adj = adj, score_cell = score_spill,
    patch_sizes = seq(1, 60, 2),
    cover_mult = 2.0,
    alpha = alpha_val, f = f_val, R = R_val, r = r_val,
    eta = eta_val, nu = nu_val, kappa = kappa_val,
    topup = TRUE,
    n_mc = 2000, seed = 1
)

ggplot(df_ps, aes(x = patch_size, y = mean_cost)) +
    geom_line() +
    geom_point(size = 1.5) +
    theme_minimal() +
    labs(x = "Patch size (cells)", y = "Mean total cost")

```

# ODE Model Approach

This section explores how the proportional reduction parameter $r$ varies as a function of vaccination delay, campaign duration, and vaccine efficacy, using a standard SIR model.

We model the dynamics of Susceptible ($S$), Infectious ($I$), Recovered ($R$), and Vaccinated ($V$) individuals. The vaccination campaign is implemented as a flow from $S$ to $V$ at a daily rate $\rho$ during the campaign window $[t_{\text{start}}, t_{\text{start}} + t_{\text{dur}}]$.

The proportional reduction $r$ is defined as:
$$
r = 1 - \frac{\text{Cumulative Cases (Vaccination)}}{\text{Cumulative Cases (Baseline)}}
$$

```{r}
# Example Simulation
params <- list(
    N = 100000,
    I0 = 10,
    R0 = 2.5,
    gamma = 0.2,
    ve = 0.8,
    rho = 0.05
)

# Baseline (No vaccination)
sim_novax <- run_sir_vaccination(
    N = params$N, I0 = params$I0, R0 = params$R0, gamma = params$gamma,
    rho = 0, vacc_start = 0, vacc_duration = 0, ve = 0
)

# With Vaccination (starting at day 30 for 10 days)
sim_vax <- run_sir_vaccination(
    N = params$N, I0 = params$I0, R0 = params$R0, gamma = params$gamma,
    rho = params$rho, vacc_start = 30, vacc_duration = 10, ve = params$ve
)

# Calculate r
cases_novax <- tail(sim_novax$CumCases, 1)
cases_vax <- tail(sim_vax$CumCases, 1)
r_calc <- 1 - (cases_vax / cases_novax)

print(paste0("Baseline Cases: ", round(cases_novax)))
print(paste0("Vaccinated Cases: ", round(cases_vax)))
print(paste0("Proportional Reduction r: ", round(r_calc, 3)))
```

## Sensitivity Analysis: Delay and Efficacy

We can systematically explore how $r$ changes with the delay in start time and vaccine efficacy.

```{r}
delays <- seq(10, 60, by = 5)
ves <- c(0.5, 0.7, 0.9)
R0s <- c(1.5, 2.5, 3.5)

results <- expand.grid(delay = delays, ve = ves, R0 = R0s)
results$r <- NA

for (i in seq_len(nrow(results))) {
    res <- calculate_r_ode(
        N = params$N, I0 = params$I0, R0 = results$R0[i], gamma = params$gamma,
        vacc_start = results$delay[i],
        ve = results$ve[i],
        rho = params$rho,
        vacc_duration = 10
    )
    results$r[i] <- res$r
}

ggplot(results, aes(x = delay, y = r, color = factor(ve))) +
    geom_line(linewidth = 1) +
    geom_point() +
    facet_wrap(~R0, labeller = label_both) +
    labs(
        title = "Impact of Vaccination Delay, Efficacy, and R0 on r",
        x = "Vaccination Start Day",
        y = "Proportional Reduction (r)",
        color = "Vaccine Efficacy"
    ) +
    theme_light()
```

# Overall Effectiveness Approach

Alternatively, we can compute the expected number of cases by directly applying an "Overall Effectiveness" factor to the baseline cases. This approach simplifies the dynamics by assuming that the total impact of vaccination (direct + indirect effects) can be captured by a single effectiveness parameter $VE_{overall}$.

$$
\text{Cases}_{post} = \text{Cases}_{baseline} \times (1 - VE_{overall})
$$

Where $VE_{overall}$ is a function of coverage and direct vaccine efficacy ($VE_{direct}$). A simple linear approximation is $VE_{overall} = \text{Coverage} \times VE_{direct}$.

```{r}
# Example Calculation
baseline_cases <- 50000
coverage_levels <- seq(0, 1, by = 0.1)
ve_direct_val <- 0.7

# Simple Linear Model
cases_linear <- sapply(coverage_levels, function(cov) {
    calculate_cases_overall_effectiveness(baseline_cases, cov, ve_direct_val)$cases_post
})

# Non-linear Model (toy herd immunity effect)
cases_nonlinear <- sapply(coverage_levels, function(cov) {
    # Custom non-linear function
    nonlinear_func <- function(c) pmin(1, c * ve_direct_val + (c^2) * 0.4)
    calculate_cases_overall_effectiveness(
        baseline_cases, cov, ve_direct_val,
        ve_indirect_func = nonlinear_func
    )$cases_post
})

df_oe <- data.frame(
    coverage = rep(coverage_levels, 2),
    cases = c(cases_linear, cases_nonlinear),
    model = rep(c("Linear", "Non-linear (Herd Immunity)"), each = length(coverage_levels))
)

ggplot(df_oe, aes(x = coverage, y = cases, color = model)) +
    geom_line(linewidth = 1) +
    labs(
        title = "Cases vs Coverage: Overall Effectiveness Models",
        subtitle = paste0("Baseline Cases: ", baseline_cases, ", Direct VE: ", ve_direct_val),
        x = "Vaccination Coverage",
        y = "Total Cases"
    ) +
    theme_light()
```

# Comparison of ODE and Overall Effectiveness Approaches

In this section, we compare the reduction in cumulative cases estimated by the full ODE model against the simplified "Overall Effectiveness" approach, where the latter is informed by the Indirect Vaccine Effectiveness (IVE) derived from the ODE model.

We transform the time-dependent IVE into a single summary scalar (the final IVE) and use it to adjust the baseline cases.

$$
\text{IVE}(t) = 1 - \frac{\text{Risk}_{\text{unvax, vax}}(t)}{\text{Risk}_{\text{unvax, novax}}(t)}
$$

We check if:
$$
\text{Cases}_{\text{ODE}} \approx \text{Cases}_{\text{Baseline}} \times (1 - \text{Total Effectiveness})
$$
where Total Effectiveness combines simple direct protection and the derived IVE.

```{r}
# Parameters
test_N <- 100000
test_I0 <- 10
test_R0 <- 2.0
test_gamma <- 0.2
test_ve <- 0.7
test_rho <- 0.05
test_start <- 20
test_dur <- 20

# 1. ODE IVE Calculation
ive_res <- calculate_ive_ode(
    N = test_N, I0 = test_I0, R0 = test_R0, gamma = test_gamma,
    ve = test_ve, rho = test_rho, vacc_start = test_start, vacc_duration = test_dur
)

# Extract final IVE
final_ive <- ive_res$final_ive
print(paste("Final IVE from ODE:", round(final_ive, 4)))

# Plot IVE over time
df_ive <- data.frame(time = ive_res$time, ive = ive_res$ive_series)
ggplot(df_ive, aes(x = time, y = ive)) +
    geom_line(color = "purple", linewidth = 1) +
    labs(
        title = "Indirect Vaccine Effectiveness (IVE) over Time",
        x = "Time (days)", y = "IVE"
    ) +
    theme_light()

# 2. Compare Case Reductions
# ODE Results
cases_baseline_ode <- tail(ive_res$risk_novax, 1) * test_N # Approx using risk*N or just calculate_r_ode output
# Let's get exact cases from the ODE objects inside calculate_ive_ode if possible, or re-run lightly.
# For exact comparison, let's re-run verify:
ode_check <- calculate_r_ode(
    N = test_N, I0 = test_I0, R0 = test_R0, gamma = test_gamma,
    ve = test_ve, rho = test_rho, vacc_start = test_start, vacc_duration = test_dur
)
ode_cases_vax <- tail(ode_check$sim_vax$CumCases, 1)
ode_cases_novax <- tail(ode_check$sim_novax$CumCases, 1)
ode_reduction <- 1 - (ode_cases_vax / ode_cases_novax)

# Simplified Approach Calculation
# Calculate Coverage: In the ODE, how many were vaccinated?
# V compartment at end
V_final <- tail(ode_check$sim_vax$V, 1)
coverage <- V_final / test_N

# Total Effectiveness formula approximation
# reduction = (coverage * ve) + (1 - coverage * ve) * final_ive ?
# This assumes IVE applies to the remaining susceptibility of the population?
# Or more simply:
# Direct protection prevents: coverage * ve * (Baseline Risk?)
# Indirect protection prevents: (1 - Direct_Protected) * IVE * (Baseline Risk?)

# Let's try the combined efficacy formula:
# TE = 1 - (1 - coverage * ve) * (1 - final_ive)
te_approx <- 1 - (1 - coverage * test_ve) * (1 - final_ive)

cases_simplified <- ode_cases_novax * (1 - te_approx)

print(paste("ODE Reduction:", round(ode_reduction, 4)))
print(paste("Simplified TE Approx:", round(te_approx, 4)))
print(paste("ODE Cases:", round(ode_cases_vax)))
print(paste("Simplified Cases:", round(cases_simplified)))

vals <- c(ode_reduction, te_approx)
names(vals) <- c("ODE Reduction", "Simplified TE")
barplot(vals, main = "Comparison of Reduction Estimates", col = c("steelblue", "orange"), ylim = c(0, 1))
```



